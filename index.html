<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>UNITE Roulette｜今日のポケモンは君だ</title>
    <link rel="canonical" href="https://unite-roulette.site/" />

	<meta property="og:title" content="UNITE Roulette｜今日のポケモンは君だ" />
	<meta property="og:description" content="UNITE Rouletteは、ポケモンユナイトのピックやレーン選択に「偶然」を取り入れ、マンネリを解消して新しい楽しみ方を発見する戦術ルーレットです。" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="https://unite-roulette.site/" />
	<meta property="og:image" content="https://unite-roulette.site/img/ogp.png" />
	<meta property="og:image:width" content="1200" />
	<meta property="og:image:height" content="630" />
	<meta property="og:locale" content="ja_JP" />

	<meta name="twitter:card" content="summary_large_image" />
	<meta name="twitter:title" content="UNITE Roulette｜今日のポケモンは君だ" />
	<meta name="twitter:description" content="UNITE Rouletteは、ポケモンユナイトのピックやレーン選択に「偶然」を取り入れ、マンネリを解消して新しい楽しみ方を発見する戦術ルーレットです。" />
	<meta name="twitter:image" content="https://unite-roulette.site/img/ogp.png" />

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CHKNB5BK2H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-CHKNB5BK2H');
</script>

<!-- React & ReactDOM -->
    <script onerror="window.__boot && window.__boot.libError('React', 'https://unpkg.com/react@18/umd/react.development.js')" crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script onerror="window.__boot && window.__boot.libError('ReactDOM', 'https://unpkg.com/react-dom@18/umd/react-dom.development.js')" crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script onerror="window.__boot && window.__boot.libError('Babel', 'https://unpkg.com/@babel/standalone/babel.min.js')" src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script onerror="window.__boot && window.__boot.libError('Tailwind', 'https://cdn.tailwindcss.com')" src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Mochiy+Pop+One&family=Zen+Maru+Gothic:wght@500;700;900&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        aeos: { violet: '#8B5CF6', cyan: '#06B6D4', dark: '#4C1D95', darker: '#2E1065' },
                        neon: { yellow: '#FACC15', pink: '#F472B6', blue: '#60A5FA', cyan: '#22d3ee' }
                    },
                    fontFamily: {
                        sans: ['"Zen Maru Gothic"', 'sans-serif'],
                        display: ['"Fredoka"', 'sans-serif'],
                        jp: ['"Mochiy Pop One"', 'sans-serif'],
                    },
                    animation: {
                        'pulse-glow': 'pulse-glow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'float': 'float 6s ease-in-out infinite',
                        'glitch': 'glitch 0.3s cubic-bezier(.25, .46, .45, .94) both infinite',
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'shimmer': 'shimmer 2.5s infinite linear',
                        'breathing': 'breathing 3s ease-in-out infinite',
                    },
                    keyframes: {
                        'pulse-glow': { '0%, 100%': { opacity: 1 }, '50%': { opacity: .8 } },
                        float: { '0%, 100%': { transform: 'translateY(0)' }, '50%': { transform: 'translateY(-10px)' } },
                        glitch: {
                            '0%': { transform: 'translate(0)' }, '20%': { transform: 'translate(-2px, 2px)' },
                            '40%': { transform: 'translate(-2px, -2px)' }, '60%': { transform: 'translate(2px, 2px)' },
                            '80%': { transform: 'translate(2px, -2px)' }, '100%': { transform: 'translate(0)' }
                        },
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-1px, 0, 0)' },
                            '20%, 80%': { transform: 'translate3d(2px, 0, 0)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0)' },
                            '40%, 60%': { transform: 'translate3d(4px, 0, 0)' }
                        },
                        shimmer: {
                            '0%': { transform: 'translateX(-150%) skewX(-15deg)' },
                            '100%': { transform: 'translateX(150%) skewX(-15deg)' }
                        },
                        breathing: {
                            '0%, 100%': { filter: 'brightness(1)' },
                            '50%': { filter: 'brightness(1.15)' }
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body {
            background: linear-gradient(135deg, #4c1d95 0%, #7c3aed 50%, #06b6d4 100%);
            background-attachment: fixed;
            color: white;
            overflow-x: hidden;
            font-family: 'Zen Maru Gothic', sans-serif;
            min-height: 100vh;
            margin: 0;
            -webkit-tap-highlight-color: transparent;
        }
        #root {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }
        .glass-button {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }
        .glass-button:active { transform: scale(0.95); }
        .glass-button.selected {
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.6), rgba(139, 92, 246, 0.6));
            border-color: #FACC15;
            box-shadow: 0 0 15px rgba(244, 114, 182, 0.5);
        }
        /* Spin Button Physical Feel */
        .spin-button-container {
            transition: transform 0.1s ease;
        }
        .spin-button-container:active {
            transform: translateY(4px);
        }
        .spin-button-inner {
            box-shadow: 0 6px 0 #9d174d, 0 15px 20px rgba(0,0,0,0.4);
            transition: box-shadow 0.1s ease;
        }
        .spin-button-container:active .spin-button-inner {
            box-shadow: 0 0 0 #9d174d, 0 0 5px rgba(0,0,0,0.4);
        }
        
        .text-glow { text-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2); border-radius: 4px; }
        /* Hide scrollbars but keep scroll behavior (tile board) */
        .no-scrollbar { scrollbar-width: none; -ms-overflow-style: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .toggle-checkbox:checked { right: 0; border-color: #68D391; }
        .toggle-checkbox:checked + .toggle-label { background-color: #68D391; }
        .safe-pb { padding-bottom: max(20px, env(safe-area-inset-bottom)); }
        
        .break-words-anywhere {
            overflow-wrap: anywhere;
            word-break: break-word;
        }
    </style>
</head>
<body>
    <div id="root"></div>
<script type="text/babel">
        const { useState, useEffect, useMemo, useRef, useCallback } = React;

        // --- Config & Data Injection (Ver 24.0) ---
        // 構成保証ロジック用設定: ロール保証の対象となる例外ポケモンID (例: スイクン)
        // タンク/サポート枠として扱うポケモンのIDリスト
        const CONFIG_TANK_SUPPORT_EXCEPTIONS = [7]; 


        // --- Tournament Meta (PUACL 2026 JAPAN LEAGUE Day1-5) ---
        // PUACL 2026 JAPAN LEAGUE Day1〜Day5（全293試合）の全日程合計ピック実績
        // 足切りライン: PICK数12回以上（約4%ライン）
        const TOURNAMENT_META_DATA = [
            { name: "バシャーモ", count: 156 },
            { name: "カビゴン", count: 127 },
            { name: "カメックス", count: 124 },
            { name: "リーフィア", count: 114 },
            { name: "ミュウツーX", count: 113 },
            { name: "ザシアン", count: 104 },
            { name: "ストライク", count: 99 },
            { name: "ハピナス", count: 95 },
            { name: "ミライドン", count: 91 },
            { name: "ミュウ", count: 87 },
            { name: "マホイップ", count: 85 },
            { name: "コダック", count: 83 },
            { name: "ドードリオ", count: 82 },
            { name: "バリヤード", count: 79 },
            { name: "イワパレス", count: 76 },
            { name: "ミミッキュ", count: 76 },
            { name: "マッシブーン", count: 74 },
            { name: "ウーラオス", count: 70 },
            { name: "ギャラドス", count: 69 },
            { name: "メガルカリオ", count: 68 },
            { name: "ワタシラガ", count: 66 },
            { name: "アローラライチュウ", count: 64 },
            { name: "ミュウツーY", count: 62 },
            { name: "ピクシー", count: 58 },
            { name: "シャワーズ", count: 57 },
            { name: "マンムー", count: 57 },
            { name: "メガリザードンX", count: 53 },
            { name: "アマージョ", count: 50 },
            { name: "ブラッキー", count: 45 },
            { name: "ヤドラン", count: 43 },
            { name: "ラティアス", count: 42 },
            { name: "メガギャラドス", count: 41 },
            { name: "フーパ", count: 40 },
            { name: "スイクン", count: 34 },
            { name: "ルカリオ", count: 28 },
            { name: "エンペルト", count: 25 },
            { name: "オーロット", count: 25 },
            { name: "キュワワー", count: 24 },
            { name: "インテレオン", count: 24 },
            { name: "ダダリン", count: 23 },
            { name: "ダークライ", count: 20 },
            { name: "パーモット", count: 19 },
            { name: "ラティオス", count: 18 },
            { name: "ラプラス", count: 13 },
            { name: "エーフィ", count: 13 },
            { name: "フシギバナ", count: 12 },
        ];
        const TOURNAMENT_META_SET = new Set(TOURNAMENT_META_DATA.map(d => d.name));

        // --- Pick-rate Top/Bottom (uniteapi 2026-01-11) ---
        // 仕様: 上位25匹 / 下位25匹 固定（名称に上位/Bは使用しない）
        // 注意: ハッサムとストライクはルーレット上は別ポケモンとして扱うため、両方を上位側に含める
        const PICKRATE_TOP_SET = new Set([
            "カメックス", "シャワーズ", "ジュナイパー", "グレイシア", "ハッサム", "ストライク", "ミュウツーX", "スイクン", "ミミッキュ", "ファイアロー",
            "メガリザードンY", "ゲッコウガ", "インテレオン", "ミュウツーY", "エーフィ", "メガルカリオ", "ブラッキー", "バシャーモ", "ピクシー", "ヤドラン",
            "ゲンガー", "エースバーン", "メガリザードンX", "カイリキー", "メガギャラドス", "カビゴン"
        ]);
        const PICKRATE_BOTTOM_SET = new Set([
            "ダークライ", "ギルガルド", "ドラパルト", "パーモット", "ギャラドス", "ヤミラミ", "ザシアン", "マリルリ", "ソウブレイズ", "ウーラオス",
            "ニャース", "コダック", "グレンアルマ", "バンギラス", "ヌメルゴン", "メタグロス", "カイリュー", "ヨクバリス", "シャンデラ", "ガラルギャロップ",
            "ガブリアス", "デカヌチャン", "ウッウ", "ジュラルドン", "タイレーツ"
        ]);

        // Looksデータマッピング (Index 4)
        const LOOKS_MAP = {
            "1": [1, 5], "2": [0, 3], "3": [1, 5], "4": [0, 4, 6], "5": [2, 4, 6],
            "6": [2, 6], "7": [1, 6], "8": [3, 5], "9": [4], "10": [0, 6],
            "11": [3, 4], "12": [1, 6], "13": [1, 5], "14": [5], "15": [1, 5],
            "16": [2, 3, 4], "17": [0, 4, 6], "18": [3, 4], "19": [3, 5], "20": [1, 6],
            "21": [5], "22": [0, 6], "23": [1, 2, 6], "24": [3, 4], "25": [2, 3],
            "26": [5], "27": [3], "28": [0, 1, 6], "29": [0], "30": [2, 4],
            "31": [3, 4], "32": [3, 4], "33": [3], "34": [0, 2, 5], "35": [5, 6],
            "36": [0, 4], "37": [3], "38": [0, 2], "39": [2], "40": [1],
            "41": [5], "42": [5], "43": [3], "44": [5], "45": [2],
            "46": [1, 6], "47": [4], "48": [], "49": [4, 6], "50": [],
            "51": [1, 5], "52": [5], "53": [1], "54": [4, 5], "55": [2],
            "56": [6], "57": [3], "58": [1, 5], "59": [1, 5], "60": [3, 4],
            "61": [2], "62": [4], "63": [3], "64": [], "65": [4, 5],
            "66": [4, 6], "67": [3, 4], "68": [3, 4], "69": [2, 6], "70": [3, 4],
            "71": [1, 6], "72": [4, 5], "73": [1, 6], "74": [0], "75": [4, 6],
            "76": [4], "77": [4], "78": [0], "79": [0], "80": [5],
            "81": [5], "82": [1], "83": [3, 6], "84": [3], "85": [3, 4],
            "86": [1, 6]
        };

        // --- Icons ---
        const IconBase = ({ children, className, size = 24 }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} >{children}</svg>
        );
        const Zap = (p) => <IconBase {...p}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></IconBase>;
        const MapPin = (p) => <IconBase {...p}><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z" /><circle cx="12" cy="10" r="3" /></IconBase>;
        const Sword = (p) => <IconBase {...p}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5" /><line x1="13" y1="19" x2="19" y2="13" /><line x1="16" y1="16" x2="20" y2="20" /><line x1="19" y1="21" x2="21" y2="19" /></IconBase>;
        const Eye = (p) => <IconBase {...p}><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></IconBase>;
        const RefreshCw = (p) => <IconBase {...p}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M3 21v-5h5" /></IconBase>;
        const Share2 = (p) => <IconBase {...p}><circle cx="18" cy="5" r="3" /><circle cx="6" cy="12" r="3" /><circle cx="18" cy="19" r="3" /><line x1="8.59" y1="13.51" x2="15.42" y2="17.49" /><line x1="15.41" y1="6.51" x2="8.59" y2="10.49" /></IconBase>;
        const Users = (p) => <IconBase {...p}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" /><circle cx="9" cy="7" r="4" /><path d="M22 21v-2a4 4 0 0 0-3-3.87" /><path d="M16 3.13a4 4 0 0 1 0 7.75" /></IconBase>;
        const CheckCircle = (p) => <IconBase {...p}><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></IconBase>;
        const Camera = (p) => <IconBase {...p}><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></IconBase>;
        const SettingsIcon = (p) => <IconBase {...p}><circle cx="12" cy="12" r="3" /><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z" /></IconBase>;
        const ShieldCheck = (p) => <IconBase {...p}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="m9 12 2 2 4-4"/></IconBase>;
const Trophy = (p) => <IconBase {...p}>
    <path d="M8 21h8" />
    <path d="M12 17v4" />
    <path d="M7 4h10v3a5 5 0 0 1-10 0V4Z" />
    <path d="M5 7h2a5 5 0 0 1-2 4V7Z" />
    <path d="M19 7h-2a5 5 0 0 0 2 4V7Z" />
</IconBase>;
        const DatabaseIcon = (p) => <IconBase {...p}><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></IconBase>;
        const ArrowLeft = (p) => <IconBase {...p}><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></IconBase>;
        const FilterIcon = (p) => <IconBase {...p}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></IconBase>;
        const Dices = (p) => <IconBase {...p}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><path d="M15 9h.01"/><path d="M9 15h.01"/><path d="M9 9h.01"/><path d="M15 15h.01"/></IconBase>;

        // --- Confetti Effect (Optimized) ---
        const DEFAULT_CONFETTI_COLORS = ['#F472B6', '#22d3ee', '#FACC15', '#ffffff'];
        const ConfettiEffect = React.memo(({ trigger = true, colors = DEFAULT_CONFETTI_COLORS }) => {
            const canvasRef = useRef(null);
            useEffect(() => {
                if (!trigger || !canvasRef.current) return;
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                let animationId;
                const setCanvasSize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
                setCanvasSize();
                window.addEventListener('resize', setCanvasSize);
                const particleCount = 100; const particles = [];
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        x: Math.random() * canvas.width, y: Math.random() * canvas.height - canvas.height,
                        vx: Math.random() * 4 - 2, vy: Math.random() * 6 + 8,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        size: Math.random() * 5 + 2, rotation: Math.random() * 360, rotationSpeed: Math.random() * 10 - 5
                    });
                }
                const animate = () => {
                    if (!trigger) return; // Optimization check
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    let active = false;
                    particles.forEach(p => {
                        p.x += p.vx; p.y += p.vy; p.rotation += p.rotationSpeed;
                        if (p.y < canvas.height) {
                            active = true;
                            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate((p.rotation * Math.PI) / 180);
                            ctx.fillStyle = p.color; ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size); ctx.restore();
                        }
                    });
                    if (active) animationId = requestAnimationFrame(animate);
                };
                animate();
                return () => { cancelAnimationFrame(animationId); window.removeEventListener('resize', setCanvasSize); };
            }, [trigger, colors]);
            return <canvas ref={canvasRef} style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', pointerEvents: 'none', zIndex: 9999 }} />;
        });

        // --- Audio Engine ---
        const useAudio = () => {
            const audioCtxRef = useRef(null);
            const tickIntervalRef = useRef(null);
            const initAudio = useCallback(() => {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) return;
                    if (!audioCtxRef.current) audioCtxRef.current = new AudioContext();
                    if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume().catch(() => {});
                } catch(e) {}
            }, []);
            const playTone = useCallback((freq, type, duration, vol) => {
                if (!audioCtxRef.current) return;
                try {
                    const ctx = audioCtxRef.current;
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = type; osc.frequency.setValueAtTime(freq, ctx.currentTime);
                    gain.gain.setValueAtTime(vol, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.start(); osc.stop(ctx.currentTime + duration);
                } catch(e){}
            }, []);
            const startSpinSound = useCallback(() => {
                initAudio();
                if (tickIntervalRef.current) clearInterval(tickIntervalRef.current);
                let speed = 50;
                tickIntervalRef.current = setInterval(() => { playTone(800, 'square', 0.05, 0.05); }, speed);
            }, [playTone, initAudio]);
            const slowdownSpinSound = useCallback(() => {
                if (tickIntervalRef.current) clearInterval(tickIntervalRef.current);
                let speed = 100; let count = 0;
                const slowLoop = () => {
                    if (count >= 4) return;
                    playTone(600, 'square', 0.1, 0.05);
                    speed += 120; count++;
                    setTimeout(slowLoop, speed);
                };
                slowLoop();
            }, [playTone]);
            const playResultSound = useCallback((isMatch) => {
                if (tickIntervalRef.current) clearInterval(tickIntervalRef.current);
                if (isMatch) {
                    setTimeout(() => playTone(523.25, 'triangle', 0.6, 0.1), 0);
                    setTimeout(() => playTone(659.25, 'triangle', 0.6, 0.1), 150);
                    setTimeout(() => playTone(783.99, 'triangle', 1.0, 0.1), 300);
                } else {
                    playTone(150, 'sawtooth', 0.4, 0.1);
                    setTimeout(() => playTone(100, 'sawtooth', 0.4, 0.1), 150);
                }
            }, [playTone]);
            return { startSpinSound, slowdownSpinSound, playResultSound };
        };

        // --- Data Definitions (Ver 24.0) ---
        // dbIndex: POKEMON_DBのcats配列におけるインデックス (0:Elements, 1:Gens, 2:Styles, 3:Growth(廃止), 4:Looks)
        const CATEGORY_MODES = [
            { id: 'random', label: 'Random', sub: 'ランダム', icon: Dices, items: [], dbIndex: null },
            { id: 'elements', label: 'Elements', sub: 'タイプ', icon: Zap, items: ['ほのお','みず','ネイチャー','エスパー','ゴースト','あく','フェアリー','ドラゴン','でんき','かくとう','ノーマル','マテリアル'], dbIndex: 0 },
            { id: 'generations', label: 'Generations', sub: '地方', icon: MapPin, items: ['カントー','ジョウト','ホウエン','シンオウ','イッシュ','カロス','アローラ','ガラル','パルデア'], dbIndex: 1 },
            { id: 'styles', label: 'Styles', sub: '役割', icon: Sword, items: ['近接物理\nスピード','近接物理\nバランス','遠隔物理\nADC','遠隔特攻\nメイジ','近接特攻\nキャリー','ディフェ\nンス','サポート','トリッ\nキー'], dbIndex: 2 },
            // Growth (id: 'growth') は廃止 (インデックス3はデータ上には残るがUIからは削除)
            { id: 'looks', label: 'Looks', sub: '容姿', icon: Eye, items: ['武器・武装','犬・猫・狐','マッスル・硬','モンスター・異形','空飛ぶ・浮遊','カワイイ','イケメン・美形'], dbIndex: 4 },
        ];
        
        const FILTER_OPTIONS = [
            { id: 'default', name: '指定なし' },
            { id: 'tournament', name: '大会メタ' },
            { id: 'carry', name: 'キャリー' },
            { id: 'tank_sup', name: 'サポタン' },
            { id: 'popular', name: 'ピック率上位' },
            { id: 'endangered', name: 'ピック率下位' },
        ];
        const PLAYER_COUNTS = [
            { count: 1, label: 'SOLO' }, { count: 2, label: 'DUO' }, { count: 3, label: 'TRIO' }, { count: 5, label: 'FULL' },
        ];
        const LANE_POOL_TEMPLATE = ['上レーン', '上レーン', '中央エリア', '下レーン', '下レーン'];

        // Helper
        const _p = (id, name, role, lane, dexId, group, tags, cats) => ({ id, name, role, lane, dexId, group, tags, cats });

        // Database Initialization
        const RAW_POKEMON_DB = [
            // Popular (上位ピック)
            _p(11, "メガリザードンX", "All-Rounder", "Mid", 10034, 'A', ["#煉獄のドラゴン","#進化して殴り込み","#ユナイト技＝確殺","#進化するまで守って"], [[0,7], [0], [1], [2]]),
            _p(45, "カイリキー", "All-Rounder", "Top", 68, 'A', ["#豪腕の格闘家","#妨害無効で突っ込む","#ユナイト技オラオラ","#ごり押しこそ正義"], [[9], [0], [1], [2]]),
            _p(16, "メガギャラドス", "All-Rounder", "Top", 10041, 'A', ["#破壊の化身","#最強の通常攻撃連打","#圧倒的フィジカル","#コイキング時代の恨み"], [[1,5], [0], [1], [1]]),
            _p(19, "カビゴン", "Defender", "Top/Bot", 143, 'A', ["#通せんぼの巨壁","#ヘビーボンバーで奇襲","#オブジェクト戦の守護神","#寝てるだけで最強"], [[10], [0], [5], [0]]),
            _p(2, "カメックス", "Defender", "Top/Bot", 9, 'A', ["#激流の要塞","#スピンで敵陣を荒らす","#CC無効の暴走戦車","#ハイドロポンプ発射台"], [[1], [0], [5], [2]]),
            _p(1, "シャワーズ", "Defender", "Top/Bot", 134, 'A', ["#不沈艦","#無限回復","#詰ませ性能No.1","#回復が追いつかない"], [[1], [0], [5], [1]]),
            _p(4, "ジュナイパー", "Attacker", "Bot", 724, 'A', ["#森のアーチャー","#影縫いで遠距離狙撃","#ラストヒット職人","#接近されたら即終了"], [[2,4], [6], [2], [2]]),
            _p(3, "グレイシア", "Attacker", "Mid/Bot", 471, 'A', ["#絶対零度の狙撃手","#つらら針で追尾攻撃","#必中・高火力の暴力","#近づく前に溶かす"], [[11], [3], [3], [1]]),
            _p(5, "ハッサム", "All-Rounder", "Top/Mid", 212, 'A', ["#真紅の閃光","#殴り合いなら負けない","#高機動ファイター","#進化前が一番弱い"], [[2,11], [1], [1], [1]]),
            _p(6, "ミュウツーX", "All-Rounder", "Top", 10043, 'A', ["#遺伝子操作の結晶","#未来予知で捕まえて殴る","#理不尽なステータス","#メガ進化までが長い"], [[3,9], [0], [1], [0]]),
            _p(7, "スイクン", "All-Rounder", "Top/Bot", 245, 'A', ["#北風の化身","#逃げる敵を無限に追跡","#タンク兼アサシン","#清らかなるハラス"], [[1], [1], [4], [0]]),
            _p(8, "ミミッキュ", "All-Rounder", "Mid/Top", 778, 'A', ["#化けの皮の下","#影撃ちでどこまでも追う","#最強の無敵技持ち","#皮剥がれたら脆い"], [[4,6], [6], [1], [0]]),
            _p(9, "ファイアロー", "Speedster", "Mid", 663, 'A', ["#音速の鳥","#空を飛んで後衛を消す","#ゴール泥棒のプロ","#ブレイブバード特攻死"], [[0,2], [5], [0], [2]]),
            _p(84, "メガリザードンY", "All-Rounder", "Mid", 10035, 'A', ["#特攻特化ドラゴン","#無限射程の焼き尽くし","#Xとは違うのだよ","#技当てないと"], [[0,2], [0], [1], [2]]),
            _p(10, "ゲッコウガ", "Attacker", "Mid/Bot", 658, 'A', ["#変幻自在の忍","#分身と手裏剣の弾幕","#ユナイト技で着地狩り","#紙耐久の極み"], [[1,5], [5], [2], [2]]),
            _p(17, "インテレオン", "Attacker", "Bot", 818, 'A', ["#諜報部員007","#壁越しからの狙撃","#クリティカル確定演出","#懐に入られたら終わり"], [[1], [7], [3], [2]]),
            _p(75, "ミュウツーY", "Attacker", "Bot", 10044, 'A', ["#最強の遺伝子Y","#無限射程で一方的に殴る","#メガ進化で宇宙","#通常攻撃連打ゲー"], [[3], [0], [3], [0]]),
            _p(13, "エーフィ", "Attacker", "Top/Bot", 196, 'A', ["#太陽の予言者","#サイコショックで拘束","#序盤から高火力","#ユナイトで全員浮かす"], [[3], [1], [3], [1]]),
            _p(12, "メガルカリオ", "All-Rounder", "Top", 10059, 'A', ["#波動の勇者","#波動の力が最大化","#進化した瞬間の圧","#メガシンカの無駄遣い"], [[9,11], [3], [1], [0]]),
            _p(15, "ブラッキー", "Defender", "Top/Bot", 197, 'A', ["#月光の守護者","#黒い眼差しで逃さない","#ヘイト集め職人","#火力は期待しないで"], [[5], [1], [5], [1]]),
            _p(69, "バシャーモ", "All-Rounder", "Top/Mid", 257, 'A', ["#猛火の蹴撃","#技を切り替えてコンボ","#技スロットが足りない","#オーバーヒート"], [[0,9], [2], [1], [2]]),
            _p(14, "ピクシー", "Supporter", "Top", 36, 'A', ["#月の妖精","#重力で移動技を封殺","#回復ゾンビ製造機","#味方がいないと無力"], [[6], [0], [6], [1]]),
            _p(44, "ヤドラン", "Defender", "Top/Bot", 80, 'A', ["#鈍感な天才","#ユナイト技で強制停止","#特性でHPが減らない","#味方依存度高め"], [[1,3], [0], [5], [1]]),
            _p(18, "ゲンガー", "Speedster", "Mid", 94, 'A', ["#影の住人","#状態異常にして溶かす","#一瞬で消えるHPバー","#ヘドロ爆弾外したら逃走"], [[4,2], [0], [4], [2]]),
            _p(20, "エースバーン", "Attacker", "Bot/Mid", 815, 'A', ["#フィールドのストライカー","#遠距離からの蹴撃","#ブッシュ待機のエース","#立ち位置ミスで即死"], [[0], [7], [2], [2]]),

            // Endangered (下位ピック)
            _p(73, "マスカーニャ", "Speedster", "Mid", 908, 'B', ["#トリックフラワー","#確定急所の花爆弾","#変幻自在の猫","#分身で撹乱"], [[2,5], [8], [0], [2]]),
            _p(67, "ダークライ", "Speedster", "Mid", 491, 'B', ["#悪夢の支配者","#ダークホールで眠らせる","#眠らせてからが本番","#悪夢を見せる"], [[5], [3], [4], [0]]),
            _p(74, "ギルガルド", "All-Rounder", "Top", 681, 'B', ["#聖剣の構え","#シールドとブレード切替","#ジャンケン最強","#盾のまま殴られる"], [[11,4], [5], [1], [2]]),
            _p(68, "ドラパルト", "Attacker", "Mid/Bot", 887, 'B', ["#ステルス戦闘機","#ドラゴンアロー乱射","#キルリセットの嵐","#ステルスで奇襲"], [[4,7], [7], [2], [2]]),
            _p(81, "パーモット", "All-Rounder", "Mid", 923, 'B', ["#電気の拳","#でんこうそうげきで突撃","#再起の祈りで蘇生","#バッテリー切れ"], [[8,9], [8], [1], [2]]),
            _p(24, "ギャラドス", "All-Rounder", "Top", 130, 'B', ["#忍耐の鯉","#ゲージ溜めて進化","#進化後の爆発力","#Lv7まで実質4対5"], [[1,2], [0], [1], [1]]),
            _p(63, "ヤミラミ", "Supporter", "Top/Bot", 302, 'B', ["#宝石の泥棒","#ステルスで混乱させる","#敵ゴール破壊工作員","#視界取りのプロ"], [[5,4], [2], [7], [0]]),
            _p(28, "ザシアン", "All-Rounder", "Top/Mid", 10188, 'B', ["#剣の王","#エオスエナジーで強化","#ナーフされても王","#エナジー管理が大変"], [[6,11], [7], [1], [0]]),
            _p(21, "マリルリ", "All-Rounder", "Top", 184, 'B', ["#水上の力持ち","#アクアテールで先端当て","#タイマン最強説","#集団戦で空気になりがち"], [[1,6], [1], [1], [1]]),
            _p(22, "ソウブレイズ", "All-Rounder", "Mid", 937, 'B', ["#怨念の剣士","#無念の剣で回復攻撃","#サステインお化け","#柔らかすぎる前衛"], [[0,4], [8], [1], [1]]),
            _p(23, "ウーラオス", "All-Rounder", "Mid", 892, 'B', ["#一撃必殺の拳","#暗黒強打でシールド貫通","#一撃のロマン","#操作難易度S級"], [[9,5], [7], [1], [1]]),
            _p(26, "コダック", "Supporter", "Top/Bot", 54, 'B', ["#頭痛が痛い","#念力で広範囲スタン","#ユナイトで広域無効化","#何もしない賢者"], [[1], [0], [7], [0]]),
            _p(29, "グレンアルマ", "Attacker", "Bot", 936, 'B', ["#紅蓮の戦士","#アーマーキャノン砲撃","#相方と連携してこそ","#柔らかい砲台"], [[0,3], [8], [3], [1]]),
            _p(25, "バンギラス", "All-Rounder", "Top/Bot", 248, 'B', ["#砂嵐の暴君","#原始の力でシールド無視","#真のダメージ","#経験値を全部ください"], [[11,5], [1], [1], [2]]),
            _p(27, "ヌメルゴン", "Defender", "Top/Bot", 706, 'B', ["#雨天の要塞","#草むらに入って超回復","#無限の耐久力","#無視されるタンク"], [[7], [5], [4], [2]]),
            _p(30, "メタグロス", "All-Rounder", "Mid", 376, 'B', ["#鉄壁の計算機","#シールド無限生成","#集団戦の壁","#機動力不足の塊"], [[11,3], [2], [1], [2]]),
            _p(31, "カイリュー", "All-Rounder", "Mid/Bot", 149, 'B', ["#破壊光線の使い手","#逆鱗で暴れまわる","#オブジェクト管理職","#スタンさせられて終了"], [[7,2], [0], [2], [2]]),
            _p(33, "ヨクバリス", "Defender", "Top/Bot", 820, 'B', ["#強欲なリス","#走り回って回復＆妨害","#ヘイトを集める天才","#敵ジャングルを荒らす仕事"], [[10], [7], [7], [1]]),
            _p(32, "シャンデラ", "Attacker", "Bot", 609, 'B', ["#冥界の灯火","#視界を封じて焼く","#タンク殺しの火力","#徒歩勢を許さない"], [[4,0], [4], [3], [2]]),
            _p(35, "ガラルギャロップ", "Speedster", "Mid/Bot", 10163, 'B', ["#癒やしの駿馬","#視界外からの強襲","#常時妨害無効","#突っ込んで溶ける"], [[3,6], [7], [4], [1]]),
            _p(37, "ガブリアス", "All-Rounder", "Top", 445, 'B', ["#大地のサメ","#通常攻撃でスタック溜め","#殴り合いの鬼","#主人公(笑)"], [[7,11], [3], [1], [2]]),
            _p(34, "デカヌチャン", "All-Rounder", "Top", 959, 'B', ["#ハンマー狂","#デカハンマーで壁ドン","#氷壁の設置業者","#ハンマーがないと無力"], [[6,11], [8], [1], [2]]),
            _p(36, "ウッウ", "Attacker", "Bot", 845, 'B', ["#野生の鵜","#ピカチュウを吐き出す","#序盤のラストヒット王","#ユナイト技が固定砲台"], [[2,1], [7], [3], [0]]),
            _p(38, "ジュラルドン", "Attacker", "Bot", 884, 'B', ["#動かざる塔","#ラスターカノン全弾発射","#オブジェクト削り最速","#歩く牛乳パック"], [[7,11], [7], [2], [0]]),
            _p(39, "タイレーツ", "All-Rounder", "Top", 870, 'B', ["#背水の陣","#6体連携でフォーカス","#隊列の美学","#範囲攻撃のカモ"], [[9], [7], [1], [0]]),

            // Group C (Others)
            _p(40, "アブソル", "Speedster", "Mid", 359, 'C', ["#災いの予兆","#背後から確定急所","#急所ランク1位","#不意打ちの美学"], [[5], [2], [0], [0]]),
            _p(41, "ハピナス", "Supporter", "Top", 242, 'C', ["#慈愛の天使","#味方を守って強化","#ピンクの悪魔","#タマゴ産みマシーン"], [[10], [1], [6], [1]]),
            _p(42, "ピカチュウ", "Attacker", "Top/Bot", 25, 'C', ["#電気ネズミ","#必中エレキボール","#ユナイト技回転率No.1","#誰でも使える(極めるのは沼)"], [[8], [0], [3], [0]]),
            _p(43, "フシギバナ", "Attacker", "Bot", 3, 'C', ["#歩く要塞(花)","#花びらの舞で突撃","#ギガドレ不死身伝説","#ソーラービーム固定砲台"], [[2], [0], [3], [2]]),
            _p(46, "ゾロアーク", "Speedster", "Mid", 571, 'C', ["#幻影の覇者","#超高速コンボで翻弄","#コンボ精度S級","#操作ミス＝即死"], [[5], [4], [0], [1]]),
            _p(47, "ドードリオ", "Speedster", "Mid/Bot", 85, 'C', ["#三位一体","#走り回ってゴール","#ゴール加速装置","#操作がレースゲーム"], [[10,2], [0], [0], [1]]),
            _p(48, "バリヤード", "Supporter", "Top/Bot", 122, 'C', ["#パントマイマー","#壁を作って閉じ込める","#パワースワップで強化","#壁ハメの達人"], [[3,6], [0], [7], [0]]),
            _p(49, "サーナイト", "Attacker", "Bot", 282, 'C', ["#包容力(火力)","#未来予知で行動予測","#ユナイトで吸引","#序盤のラルトスが辛い"], [[3,6], [2], [3], [2]]),
            _p(50, "マンムー", "Defender", "Top/Bot", 473, 'C', ["#氷河期の牙","#氷漬けにして拘束","#序盤最強の門番","#CC地獄へようこそ"], [[11], [3], [5], [2]]),
            _p(51, "アローラキュウコン", "Attacker", "Bot", 10104, 'C', ["#雪山の神使い","#オーロラベールで防御","#CC漬けの刑","#雪だるま職人"], [[6,11], [6], [3], [1]]),
            _p(52, "プクリン", "Supporter", "Top/Bot", 40, 'C', ["#歌う風船","#転がる物理攻撃","#妨害無効のアイドル","#歌って眠らせるお仕事"], [[6,10], [0], [7], [1]]),
            _p(53, "マフォクシー", "Attacker", "Bot", 655, 'C', ["#炎の魔女","#マジカルフレイム連射","#ユナイト技で回復阻害","#スキル回しが忙しい"], [[0,3], [5], [3], [2]]),
            _p(54, "ミュウ", "Attacker", "Top/Bot", 151, 'C', ["#始まりの幻","#状況に合わせて技変更","#技リセットの天才","#ソーラービーム狙撃"], [[3], [0], [3], [0]]),
            _p(55, "マッシブーン", "All-Rounder", "Top", 794, 'C', ["#究極の筋肉","#吸血で回復しながら殴る","#捕まえたら離さない","#筋肉の美学"], [[2,9], [6], [1], [0]]),
            _p(56, "アマージョ", "All-Rounder", "Mid/Bot", 763, 'C', ["#女王のキック","#トリプルアクセルで舞う","#回復しながら殴る","#女王様の踏みつけ"], [[2], [6], [1], [2]]),
            _p(57, "オーロット", "Defender", "Top/Bot", 709, 'C', ["#呪いの大木","#ウッドホーンで運送","#一生死なない木","#呪いで自傷"], [[2,4], [5], [5], [1]]),
            _p(58, "リーフィア", "Speedster", "Mid/Top", 470, 'C', ["#新緑の刃","#ソーラーブレードの一撃","#ゲージ管理のプロ","#草むら待機勢"], [[2], [3], [0], [1]]),
            _p(59, "ニンフィア", "Attacker", "Bot", 700, 'C', ["#愛の戦士","#ハイパーボイスで面制圧","#ドレインキッスゾンビ","#歩き撃ちの達人"], [[6], [5], [3], [1]]),
            _p(60, "フーパ", "Supporter", "Top/Bot", 720, 'C', ["#異次元の魔神","#ホールで基地に帰還","#ユナイト技で全員集合","#味方をホールに入らない"], [[3,4], [5], [6], [0]]),
            _p(61, "イワパレス", "Defender", "Top/Bot", 558, 'C', ["#地層の主","#からやぶりで高速移動","#ステルスロックの罠","#シザークロスで壁ドン"], [[2,11], [4], [5], [1]]),
            _p(62, "ワタシラガ", "Supporter", "Top/Bot", 830, 'C', ["#綿毛の守り","#コットンガードでシールド","#通常攻撃が痛いヒーラー","#赤バフ持ちの悪魔"], [[2], [7], [6], [1]]),
            _p(64, "ラプラス", "Defender", "Top/Bot", 131, 'C', ["#波乗りタクシー","#滅びの歌で処刑","#味方を乗せて特攻","#強化攻撃で回復"], [[1,11], [0], [4], [0]]),
            _p(65, "キュワワー", "Supporter", "Top", 764, 'C', ["#花の首飾り","#味方に憑依して回復","#操作が特殊すぎる","#完全寄生型サポート"], [[6], [6], [6], [0]]),
            _p(66, "ミライドン", "Attacker", "Bot", 1008, 'C', ["#パラドックスの雷","#パラボラチャージで回復","#EX級の破壊光線","#エレキフィールド展開"], [[7,8], [8], [3], [0]]),
            _p(70, "ホウオウ", "Defender", "Top/Bot", 250, 'C', ["#虹色の不死鳥","#聖なる炎で焼き尽くす","#味方を生き返らせる","#空を飛んで逃げる"], [[0,2], [1], [5], [0]]),
            _p(71, "ゼラオラ", "Speedster", "Mid/Top", 807, 'C', ["#疾風の雷撃","#無敵状態で攻撃","#ワイルドボルト","#スパークで飛び回る"], [[8], [6], [0], [0]]),
            _p(72, "アローラライチュウ", "Attacker", "Bot", 10100, 'C', ["#サーフボーダー","#波に乗って攻撃","#サイコキネシスで拘束","#浮いてるだけ"], [[8,3], [6], [3], [1]]),
            _p(76, "ラティアス", "Supporter", "Top/Bot", 380, 'C', ["#無限の愛","#ミストボールでデバフ","#兄妹の絆","#サポート特化の妹"], [[7,3], [2], [6], [0]]),
            _p(77, "ラティオス", "Attacker", "Bot", 381, 'C', ["#無限の知性","#ラスターパージで高火力","#兄妹の絆","#高速移動砲台"], [[7,3], [2], [3], [0]]),
            _p(78, "ストライク", "Speedster", "Mid/Top", 123, 'C', ["#進化前の輝き","#ダブルウイングで切り裂く","#テクニシャン","#進化しないこだわり"], [[2], [0], [0], [0]]),
            _p(79, "ダダリン", "Attacker", "Top/Bot", 781, 'C', ["#海藻の亡霊","#アンカーショットで捕獲","#草ゴースト複合","#重い一撃"], [[2,4], [6], [1], [0]]),
            _p(80, "マホイップ", "Supporter", "Top", 869, 'C', ["#クリームの魔法","#デコレーションで超強化","#甘い罠","#味方をデコる"], [[6], [7], [6], [1]]),
            _p(82, "ニャース", "Speedster", "Mid", 52, 'C', ["#ロケット団","#ネコに小判で小銭稼ぎ","#進化前の野望","#みだれひっかき"], [[10], [0], [0], [0]]),
            _p(83, "エンペルト", "All-Rounder", "Top/Mid/Bot", 395, 'C', ["#皇帝の威厳","#渦潮で敵を拘束","#高速移動で駆け巡る","#集団戦の皇帝"], [[1,11], [3], [4], [2]]),
            _p(85, "リザードン", "All-Rounder", "Mid", 6, 'C', ["#初代御三家","#地球投げで拘束","#進化した瞬間最強","#ヒトカゲ時代は我慢"], [[0,2], [0], [1], [2]]),
            _p(86, "ルカリオ", "All-Rounder", "Top", 448, 'C', ["#波導の勇者","#神速で戦場を駆ける","#序盤の王様","#ブッシュからのコンボ"], [[9,11], [3], [1], [0]]),
        ];

        // Process Data Injection (Safety wrapper)
        const POKEMON_DB = (() => {
            try {
                return RAW_POKEMON_DB.map(p => {
                    // Inject Looks data from LOOKS_MAP using pokemon ID
                    const looksData = LOOKS_MAP[p.id] || [];
                    // Ensure cats array has index 4
                    const newCats = [...p.cats];
                    newCats[4] = looksData;
                    return { ...p, cats: newCats };
                });
            } catch (e) {
                console.error("Data Injection Failed:", e);
                return RAW_POKEMON_DB; // Fallback
            }
        })();

        // --- Components ---
        const Header = () => (
            <header className="relative z-10 w-full max-w-md md:max-w-3xl mx-auto pt-6 md:pt-12 pb-2 px-4 flex flex-col items-center text-center">
                <div className="flex items-baseline justify-center gap-2 flex-wrap w-full">
                    <h1 className="text-3xl md:text-5xl font-jp font-bold text-transparent bg-clip-text bg-gradient-to-r from-white via-neon-yellow to-white drop-shadow-lg tracking-tight leading-none mb-1">
                        UNITE Roulette
                    </h1>
                    <span className="text-xs md:text-base font-bold text-white/90 tracking-wide text-glow mb-2 font-jp">
                        &nbsp;
                    </span>
                </div>
                <p className="text-xs md:text-sm text-cyan-200 mt-1 font-jp opacity-100 font-bold tracking-wider">
                    今日のランクマ、運命を回そう！
                </p>
            </header>
        );

        // --- Database View ---
        const DatabaseView = ({ onBack, filterMode: initialFilterMode = 'all', categoryMode: initialCategoryMode = 'random', isCompGuaranteeMode: initialCompMode = false }) => {
            const [filterRole, setFilterRole] = useState('ALL');
            const [filterElement, setFilterElement] = useState('ALL');
            const [filterGeneration, setFilterGeneration] = useState('ALL');
            const [filterStyle, setFilterStyle] = useState('ALL');
            const [filterLook, setFilterLook] = useState('ALL');
            const [filterMode, setFilterMode] = useState(initialFilterMode || 'default');
            const [searchTerm, setSearchTerm] = useState('');

	            const roles = ['ALL', ...new Set(POKEMON_DB.map(p => p.role))];
            const elements = ['ALL', ...CATEGORY_MODES[1].items];
	            const generations = ['ALL', ...CATEGORY_MODES[2].items];
	            const styles = ['ALL', ...CATEGORY_MODES[3].items];
	            const looks = ['ALL', ...CATEGORY_MODES[4].items];

            const baseEligible = useMemo(() => {
                // ルーレット画面/収録ポケモンページ共通の「フィルタ」条件（useRoulette.getPool と同一ロジック）
                const mode = filterMode || 'default';
                if (mode === 'popular') return POKEMON_DB.filter(p => PICKRATE_TOP_SET.has(p.name));
                if (mode === 'endangered') return POKEMON_DB.filter(p => PICKRATE_BOTTOM_SET.has(p.name));
                if (mode === 'tournament') return POKEMON_DB.filter(p => TOURNAMENT_META_SET.has(p.name));
                if (mode === 'carry') {
                    return POKEMON_DB.filter(p => ['Attacker', 'Speedster', 'All-Rounder'].includes(p.role) && !CONFIG_TANK_SUPPORT_EXCEPTIONS.includes(p.id));
                }
                if (mode === 'tank_sup') {
                    return POKEMON_DB.filter(p => ['Defender', 'Supporter'].includes(p.role) || CONFIG_TANK_SUPPORT_EXCEPTIONS.includes(p.id));
                }
                return POKEMON_DB;
            }, [filterMode]);

	            const filteredPokemon = useMemo(() => {
	                return baseEligible.filter(p => {
	                    const matchRole = filterRole === 'ALL' || p.role === filterRole;
	                    const pElementNames = (p.cats?.[0] || []).map(idx => CATEGORY_MODES[1].items[idx]);
	                    const matchElement = filterElement === 'ALL' || pElementNames.includes(filterElement);
	
	                    const pGenNames = (p.cats?.[1] || []).map(idx => CATEGORY_MODES[2].items[idx]);
	                    const matchGen = filterGeneration === 'ALL' || pGenNames.includes(filterGeneration);
	
	                    const pStyleNames = (p.cats?.[2] || []).map(idx => CATEGORY_MODES[3].items[idx]);
	                    const matchStyle = filterStyle === 'ALL' || pStyleNames.includes(filterStyle);
	
	                    const pLookNames = (p.cats?.[4] || []).map(idx => CATEGORY_MODES[4].items[idx]);
	                    const matchLook = filterLook === 'ALL' || pLookNames.includes(filterLook);

	                    const matchSearch = searchTerm === '' || p.name.includes(searchTerm) || p.tags.some(t => t.includes(searchTerm));                    return matchRole && matchElement && matchGen && matchStyle && matchLook && matchSearch;
	                });
	            }, [baseEligible, filterRole, filterElement, filterGeneration, filterStyle, filterLook, searchTerm]);

            return (
                <div className="w-full max-w-4xl mx-auto px-4 pb-24 animate-in fade-in slide-in-from-bottom-4 duration-500">
                    <div className="flex items-center justify-between mb-4 sticky top-0 bg-aeos-darker/90 backdrop-blur-md z-30 py-3 border-b border-white/10 -mx-4 px-4">
                        <button onClick={onBack} className="flex items-center gap-1 text-white hover:text-neon-cyan transition-colors">
                            <ArrowLeft size={20} />
                            <span className="font-bold text-sm font-sans">戻る</span>
                        </button>
                        <h2 className="text-lg font-bold text-white font-jp flex items-center gap-2">
                            <DatabaseIcon size={20} className="text-neon-yellow" />
                            収録ポケモンリスト
                            <span className="text-xs bg-white/10 px-2 py-0.5 rounded-full text-white/70 font-sans">{filteredPokemon.length}匹</span>
                        </h2>
                    </div>

                    <div className="mb-6 space-y-3">
                        <div className="glass-panel p-3 rounded-xl flex flex-col gap-3">
                            <div className="relative">
                                <input 
                                    type="text" 
                                    placeholder="名前やハッシュタグで検索..." 
                                    className="w-full bg-black/30 border border-white/20 rounded-lg py-2 md:py-3 px-4 text-sm md:text-base text-white placeholder-white/30 focus:outline-none focus:border-neon-cyan transition-colors font-sans"
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                />
                            </div>

	                            <div>
	                                <h4 className="font-bold text-white/80 text-[11px] mb-1 flex items-center gap-2 font-jp"><FilterIcon size={12}/> フィルタ</h4>
	                                <div className="flex flex-wrap gap-2">
	                                    {['default','tournament','carry','tank_sup','popular','endangered'].map((id) => {
	                                        const opt = FILTER_OPTIONS.find(o => o.id === id);
	                                        if (!opt) return null;
	                                        return (
	                                            <button
	                                                key={opt.id}
	                                                onClick={() => setFilterMode(opt.id)}
	                                                className={`px-3 py-1 rounded-full text-xs font-bold border transition-all font-jp whitespace-nowrap ${filterMode === opt.id ? 'bg-neon-yellow border-neon-yellow text-black shadow-lg' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}
	                                            >
	                                                {opt.name}
	                                            </button>
	                                        );
	                                    })}
	                                </div>
	                            </div>

	                            <div>
	                                <h4 className="font-bold text-white/80 text-[11px] mb-1 flex items-center gap-2 font-jp">Battle Style</h4>
	                                <div className="flex flex-wrap gap-2">
	                                    {roles.map(role => (
	                                        <button 
	                                            key={role} 
	                                            onClick={() => setFilterRole(role)}
	                                            className={`px-3 py-1 rounded-full text-xs font-bold border transition-all font-sans whitespace-nowrap ${filterRole === role ? 'bg-neon-yellow border-neon-yellow text-black' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}
	                                        >
	                                            {role}
	                                        </button>
	                                    ))}
	                                </div>
	                            </div>
	                            <div>
	                                <h4 className="font-bold text-white/80 text-[11px] mb-1 flex items-center gap-2 font-jp">Elements</h4>
	                                <div className="flex flex-wrap gap-2">
	                                    {elements.map(el => (
	                                        <button 
	                                            key={el} 
	                                            onClick={() => setFilterElement(el)}
	                                            className={`px-3 py-1 rounded-full text-xs font-bold border transition-all font-sans whitespace-nowrap ${filterElement === el ? 'bg-neon-cyan border-neon-cyan text-black' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}
	                                        >
	                                            {el}
	                                        </button>
	                                    ))}
	                                </div>
	                            </div>

	                            <div>
	                                <h4 className="font-bold text-white/80 text-[11px] mb-1 flex items-center gap-2 font-jp">Generations</h4>
	                                <div className="flex flex-wrap gap-2">
	                                    {generations.map(gen => (
	                                        <button
	                                            key={gen}
	                                            onClick={() => setFilterGeneration(gen)}
	                                            className={`px-3 py-1 rounded-full text-xs font-bold border transition-all font-sans whitespace-nowrap ${filterGeneration === gen ? 'bg-neon-yellow border-neon-yellow text-black' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}
	                                        >
	                                            {gen}
	                                        </button>
	                                    ))}
	                                </div>
	                            </div>

	                            <div>
	                                <h4 className="font-bold text-white/80 text-[11px] mb-1 flex items-center gap-2 font-jp">Styles</h4>
	                                <div className="flex flex-wrap gap-2">
	                                    {styles.map(st => (
	                                        <button
	                                            key={st}
	                                            onClick={() => setFilterStyle(st)}
	                                            className={`px-3 py-1 rounded-full text-xs font-bold border transition-all font-sans whitespace-nowrap ${filterStyle === st ? 'bg-neon-blue border-neon-blue text-white' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}
	                                        >
	                                            {st}
	                                        </button>
	                                    ))}
	                                </div>
	                            </div>

	                            <div>
	                                <h4 className="font-bold text-white/80 text-[11px] mb-1 flex items-center gap-2 font-jp">Looks</h4>
	                                <div className="flex flex-wrap gap-2">
	                                    {looks.map(lk => (
	                                        <button
	                                            key={lk}
	                                            onClick={() => setFilterLook(lk)}
	                                            className={`px-3 py-1 rounded-full text-xs font-bold border transition-all font-sans whitespace-nowrap ${filterLook === lk ? 'bg-neon-pink border-neon-pink text-white' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10'}`}
	                                        >
	                                            {lk}
	                                        </button>
	                                    ))}
	                                </div>
	                            </div>
                        </div>
                    </div>

                    <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3 items-stretch">
                        {filteredPokemon.map(p => (
                            <div key={p.id} className="glass-panel rounded-xl overflow-hidden hover:border-neon-cyan transition-colors relative group flex flex-col h-full">
                                <div className="absolute top-2 right-2 bg-black/60 backdrop-blur-sm px-2 py-0.5 rounded text-[10px] font-bold text-neon-yellow border border-white/10 z-10 font-sans">
                                    {p.role}
                                </div>
                                <div className="aspect-square bg-gradient-to-br from-white/5 to-transparent p-4 relative">
                                    <img 
                                        loading="lazy"
                                        src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.dexId}.png`} 
                                        alt={p.name}
                                        className="w-full h-full object-contain drop-shadow-xl group-hover:scale-110 transition-transform duration-300"
                                        onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/150x150/4C1D95/FFF?text=?'; }}
                                    />
                                </div>
	                                <div className="p-3 bg-black/20 flex-1 flex flex-col">
	                                    <h3 className="font-bold text-white text-sm font-jp mb-1 truncate">{p.name}</h3>
	                                    <div className="flex flex-wrap gap-1 mb-2">
	                                        {p.cats[0].map((typeIdx, i) => (
	                                            <span key={i} className="text-[9px] bg-neon-cyan px-1.5 py-0.5 rounded text-black border border-neon-cyan font-sans">
	                                                {CATEGORY_MODES[1].items[typeIdx]}
	                                            </span>
	                                        ))}
	                                    </div>
	                                    <div className="flex flex-wrap gap-1 mb-2">
	                                        {p.cats[1]?.slice(0, 2).map((idx, i) => (
	                                            <span key={`g-${i}`} className="text-[9px] bg-neon-yellow px-1.5 py-0.5 rounded text-black border border-neon-yellow font-sans">
	                                                {CATEGORY_MODES[2].items[idx]}
	                                            </span>
	                                        ))}
	                                        {p.cats[2]?.slice(0, 2).map((idx, i) => (
	                                            <span key={`s-${i}`} className="text-[9px] bg-neon-blue px-1.5 py-0.5 rounded text-white border border-neon-blue font-sans">
	                                                {CATEGORY_MODES[3].items[idx]}
	                                            </span>
	                                        ))}
	                                        {p.cats[4]?.slice(0, 3).map((idx, i) => (
	                                            <span key={`l-${i}`} className="text-[9px] bg-neon-pink px-1.5 py-0.5 rounded text-white border border-neon-pink font-sans">
	                                                {CATEGORY_MODES[4].items[idx]}
	                                            </span>
	                                        ))}
	                                    </div>
                                    <div className="flex items-center gap-1 text-[10px] text-white/50 mb-2 font-sans">
                                        <MapPin size={10} />
                                        <span className="truncate">{p.lane}</span>
                                    </div>
                                    <div className="space-y-0.5">
                                        {p.tags.slice(0, 2).map((tag, i) => (
                                            <div key={i} className="text-[9px] text-white/40 truncate font-sans">{tag}</div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- Lane Signal ---
        const LaneSignal = ({ phase, lane, size = 'md' }) => {
            const [activeDot, setActiveDot] = useState(null);
            
            useEffect(() => {
                let interval;
                if (phase === 'spinning') {
                    interval = setInterval(() => {
                        setActiveDot(Math.floor(Math.random() * 3));
                    }, 100);
                } else if (phase === 'result') {
                    setActiveDot(null);
                } else {
                    setActiveDot(null);
                }
                return () => clearInterval(interval);
            }, [phase]);

            const getDotClass = (index) => {
                const baseClass = "rounded-full transition-all duration-300";
                const sizeClass = size === 'sm' ? "w-2 h-2 mb-1" : "w-3 h-3 mb-1.5";
                let colorClass = "";
                if (index === 0) colorClass = "bg-neon-pink shadow-neon-pink";
                if (index === 1) colorClass = "bg-neon-yellow shadow-neon-yellow";
                if (index === 2) colorClass = "bg-neon-cyan shadow-neon-cyan";
                let isActive = false;
                if (phase === 'setup') isActive = true;
                else if (phase === 'spinning') isActive = activeDot === index;
                else if (phase === 'result') {
                     if (lane === '上レーン' && index === 0) isActive = true;
                     if (lane === '中央エリア' && index === 1) isActive = true;
                     if (lane === '下レーン' && index === 2) isActive = true;
                }
                if (phase === 'setup') return `${baseClass} ${sizeClass} ${colorClass} opacity-30 animate-pulse`; 
                if (isActive) return `${baseClass} ${sizeClass} ${colorClass} opacity-100 shadow-[0_0_8px_currentColor] scale-125`;
                return `${baseClass} ${sizeClass} ${colorClass} opacity-10`;
            };

            return (
                <div className={`flex flex-col items-center justify-center bg-black/40 rounded-full p-1 border border-white/10 ${phase === 'spinning' ? 'animate-pulse' : ''}`}>
                    <div className={getDotClass(0)}></div>
                    <div className={getDotClass(1)}></div>
                    <div className={getDotClass(2)}></div>
                </div>
            );
        };

        // --- Roulette Components ---
        const RouletteDisc = ({ phase, rotation, categoryMode, isMulti }) => {
            const modeDef = CATEGORY_MODES.find(m => m.id === categoryMode);
            const items = modeDef ? modeDef.items : [];
            const count = items.length;
            const CenterIcon = modeDef ? modeDef.icon : Zap;
            const borderClass = isMulti ? 'border-2 border-white/40' : 'border-4 border-white/80';
            
            const segments = useMemo(() => {
                if (categoryMode === 'random') {
                    const simpleCount = 8;
                    let paths = [];
                    const radius = 50; const center = 50;
                    for(let i=0; i<simpleCount; i++){
                        const startAngle = (i * 360) / simpleCount;
                        const endAngle = ((i + 1) * 360) / simpleCount;
                        const startRad = (startAngle - 90) * Math.PI / 180;
                        const endRad = (endAngle - 90) * Math.PI / 180;
                        const x1 = center + radius * Math.cos(startRad);
                        const y1 = center + radius * Math.sin(startRad);
                        const x2 = center + radius * Math.cos(endRad);
                        const y2 = center + radius * Math.sin(endRad);
                        const d = `M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 0 1 ${x2} ${y2} Z`;
                        paths.push({ d, color: i % 2 === 0 ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.15)', text: '', tx: 0, ty: 0, rotation: 0 });
                    }
                    return paths;
                }

                if (!count) return [];
                const radius = 50; const center = 50;
                let paths = [];
                for (let i = 0; i < count; i++) {
                    const startAngle = (i * 360) / count;
                    const endAngle = ((i + 1) * 360) / count;
                    const startRad = (startAngle - 90) * Math.PI / 180;
                    const endRad = (endAngle - 90) * Math.PI / 180;
                    const x1 = center + radius * Math.cos(startRad);
                    const y1 = center + radius * Math.sin(startRad);
                    const x2 = center + radius * Math.cos(endRad);
                    const y2 = center + radius * Math.sin(endRad);
                    const d = `M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 0 1 ${x2} ${y2} Z`;
                    const midAngle = startAngle + (360/count)/2;
                    const midRad = (midAngle - 90) * Math.PI / 180;
                    const textR = radius * 0.7;
                    const tx = center + textR * Math.cos(midRad);
                    const ty = center + textR * Math.sin(midRad);
                    paths.push({ d, color: i % 2 === 0 ? 'rgba(255,255,255,0.1)' : 'rgba(255,255,255,0.25)', text: items[i], tx, ty, rotation: midAngle });
                }
                return paths;
            }, [categoryMode, count]);

            return (
                <div className={`w-full h-full glass-panel rounded-full ${borderClass} overflow-hidden relative shadow-xl`} style={{ transform: `rotate(${rotation}deg)`, transition: phase === 'spinning' ? 'transform 3s cubic-bezier(0.2, 0.8, 0.2, 1)' : 'none' }}>
                    <svg viewBox="0 0 100 100" className="w-full h-full transform scale-105">
                        {segments.map((seg, i) => (
                            <g key={i}>
                                <path d={seg.d} fill={seg.color} stroke="rgba(255,255,255,0.1)" strokeWidth="0.5" />
                                {categoryMode !== 'random' && (
                                    <text x={seg.tx} y={seg.ty} fill="white" fontSize={seg.text.length > 8 ? "2.5" : seg.text.length > 5 ? "3" : "4"} fontWeight="bold" textAnchor="middle" dominantBaseline="middle" transform={`rotate(${seg.rotation + 90}, ${seg.tx}, ${seg.ty})`} style={{ textShadow: '0 0 2px rgba(0,0,0,0.5)' }}>{seg.text}</text>
                                )}
                            </g>
                        ))}
                    </svg>
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                        <div className="w-1/4 h-1/4 bg-gradient-to-br from-neon-pink to-aeos-violet rounded-full shadow-lg flex items-center justify-center border-2 border-white z-10" style={{ transform: `rotate(-${rotation}deg)` }}>
                            <CenterIcon size={20} className="text-white drop-shadow-md" />
                        </div>
                    </div>
                </div>
            );
        };

        // --- Random Tile Board (categoryMode === 'random') ---
        // 目的: 盤面を「全ポケモンのタイル」で固定し、抽選はプレイヤー別マーカーで表現する。
        // 表示要件:
        // - 画像は既存の外部URLを利用（POKEMON_DBのimageUrl想定）
        // - スピン中はランダムジャンプ + 減速（体感演出）
        // - マルチ時は同時進行、確定演出は±100ms程度の微差
        const TileSpinBoard = ({ phase, playerCount, results, tileSize = 'md', tiles: tilesProp }) => {
            const tiles = useMemo(() => {
                // "ランダム"はルーレット盤面を分割しないため、DB全体を盤面として表示する。
                // フィルタ対象（人気/低採用/等）で盤面自体を変える要件が出た場合は、ここを getPool() と同期させる。
                return Array.isArray(tilesProp) && tilesProp.length ? tilesProp : (Array.isArray(POKEMON_DB) ? POKEMON_DB : []);
            }, [tilesProp]);

            const [activeIndices, setActiveIndices] = useState(() => Array.from({ length: Math.max(1, playerCount) }, () => 0));
            const [revealedPlayers, setRevealedPlayers] = useState(() => new Set());

            // playerCount変更直後の初回スピンで「光るタイル数が少なく見える」問題の対策
            // activeIndices の長さを常に playerCount に同期させる
            useEffect(() => {
                setActiveIndices(prev => {
                    const target = Math.max(1, playerCount);
                    const next = Array.isArray(prev) ? [...prev] : [];
                    if (next.length === target) return next;
                    if (next.length > target) return next.slice(0, target);
                    while (next.length < target) next.push(next[next.length - 1] ?? 0);
                    return next;
                });
            }, [playerCount]);

            // アニメーション内で最新の activeIndices を参照するためのRef
            const activeRef = useRef(activeIndices);
            useEffect(() => { activeRef.current = activeIndices; }, [activeIndices]);

            const playerColors = [
                'ring-neon-pink',
                'ring-neon-yellow',
                'ring-neon-cyan',
                'ring-purple-400',
                'ring-emerald-400'
            ];

            // タイルは一覧性を優先して小さめ（画面内の情報量を増やす）
            const tileClass = tileSize === 'sm'
                ? 'w-12 h-12 md:w-14 md:h-14'
                : tileSize === 'lg'
                    ? 'w-16 h-16 md:w-20 md:h-20'
                    : 'w-14 h-14 md:w-18 md:h-18';

            // グリッド列幅はタイル実寸で固定しつつ、auto-fit で「入るだけ詰めて」表示
            // これにより、横方向の“間延び”を避けつつ、表示幅に応じて1行あたりの表示数が増減します。
            const gridClass = 'grid-cols-[repeat(auto-fit,3rem)] md:grid-cols-[repeat(auto-fit,3.5rem)]';

            // スピン演出: ランダムジャンプ + 減速
            // 重要: 停止タイルと結果を一致させるため、回転後半は results の当選位置へ収束させる
            useEffect(() => {
                if (phase !== 'spinning' || tiles.length === 0) return;

                let rafId = null;
                const start = performance.now();
                const totalMs = 3000; // spin() の first timeout と合わせる

                const initial = (() => {
                    const target = Math.max(1, playerCount);
                    const base = Array.isArray(activeRef.current) ? [...activeRef.current] : [];
                    if (base.length > target) return base.slice(0, target);
                    while (base.length < target) base.push(base[base.length - 1] ?? 0);
                    return base.map(v => (Number.isFinite(v) ? v : 0));
                })();

                // results が事前に渡されている場合（spin() 開始時点で確定済み）、
                // 「最終停止位置」を先に計算しておき、終盤でそこへ収束させる。
                const targetByPlayerIndex = (() => {
                    const map = {};
                    if (!Array.isArray(results) || results.length === 0) return map;
                    results.forEach((r) => {
                        const pid = r?.pokemon?.id;
                        const pname = r?.pokemon?.name;
                        const wi = tiles.findIndex(t => t && (t.id === pid || (t.name && pname && t.name === pname)));
                        if (wi < 0) return;
                        const pi = Math.max(0, Math.min(Math.max(1, playerCount) - 1, (r.playerIndex || 1) - 1));
                        map[pi] = wi;
                    });
                    return map;
                })();

                const state = {
                    nextAt: start,
                    // 開始時点が早すぎて見えない問題に対して、初速を少し遅めにする
                    stepMs: 120,
                    lastIdx: initial,
                };

                const tick = (t) => {
                    const elapsed = t - start;
                    const p = Math.min(1, elapsed / totalMs);
                    // 120ms -> 300ms へ滑らかに増やして減速（視認性を確保）
                    const targetStep = 120 + (300 - 120) * (p * p);
                    state.stepMs = targetStep;

                    if (t >= state.nextAt) {
                        const used = new Set();
                        const next = state.lastIdx.map((prev, pi) => {
                            const target = targetByPlayerIndex[pi];
                            const hasTarget = Number.isFinite(target);
                            const late = p >= 0.7; // 終盤は「当選位置へ収束」

                            let cand;
                            if (late && hasTarget) {
                                // 収束: target に向けて最短で近づく（視認性のため1ステップずつ）
                                const forward = (target - prev + tiles.length) % tiles.length;
                                const step = Math.max(1, Math.min(3, Math.ceil(forward / 6)));
                                cand = (prev + step) % tiles.length;
                                // 最終フレーム付近はピタッと合わせる
                                if (p >= 0.95) cand = target;
                            } else {
                                // ジャンプ幅を広めにしてランダム感を強める
                                const jump = 1 + Math.floor(Math.random() * Math.min(tiles.length - 1, 14));
                                cand = (prev + jump + pi) % tiles.length;
                            }

                            // 同一フレームでの重なりを避けて、参加人数分の選択が視認できるようにする
                            while (used.has(cand)) cand = (cand + 1) % tiles.length;
                            used.add(cand);
                            return cand;
                        });
                        state.lastIdx = next;
                        setActiveIndices(next);
                        state.nextAt = t + state.stepMs;
                    }

                    if (elapsed < totalMs) rafId = requestAnimationFrame(tick);
                    // 終了時点で確実に「当選位置」にスナップ（停止タイルと結果の一致を保証）
                    if (elapsed >= totalMs) {
                        const targetSnap = (() => {
                            const target = Math.max(1, playerCount);
                            const arr = Array.from({ length: target }, (_, pi) => {
                                const tIdx = targetByPlayerIndex[pi];
                                return Number.isFinite(tIdx) ? tIdx : (state.lastIdx[pi] ?? 0);
                            });
                            // 重複なしルール: ここでも最終的に重なりが出たらずらして回避
                            const used = new Set();
                            for (let i = 0; i < arr.length; i++) {
                                while (used.has(arr[i])) arr[i] = (arr[i] + 1) % tiles.length;
                                used.add(arr[i]);
                            }
                            return arr;
                        })();
                        setActiveIndices(targetSnap);
                    }
                };

                rafId = requestAnimationFrame(tick);
                return () => rafId && cancelAnimationFrame(rafId);
                // eslint-disable-next-line react-hooks/exhaustive-deps
            }, [phase, tiles.length, playerCount, results]);

            // 結果表示: 当選タイルにマーカーを同時表示（±100msの微差で自然に）
            useEffect(() => {
                if (phase !== 'result') {
                    setRevealedPlayers(new Set());
                    return;
                }
                if (!results || results.length === 0 || tiles.length === 0) return;

                // まずは『最終的に止まる位置』を同期的に確定させる（=停止タイルと結果の不一致を防ぐ）
                const snapMap = {};
                results.forEach((r, idx) => {
                    // id が一致しないケース（データ定義の差分等）に備え、name でもフォールバック
                    const winnerIndex = tiles.findIndex(t => t && r?.pokemon && (t.id === r.pokemon.id || (t.name && r.pokemon.name && t.name === r.pokemon.name)));
                    if (winnerIndex >= 0) {
                        const pi = Math.max(0, Math.min(playerCount - 1, (r.playerIndex || (idx + 1)) - 1));
                        snapMap[pi] = winnerIndex;
                    }
                });
                setActiveIndices(prev => {
                    const next = [...prev];
                    Object.entries(snapMap).forEach(([pi, wi]) => {
                        next[Number(pi)] = wi;
                    });
                    return next;
                });

                const timeouts = [];
                results.forEach((r) => {
                    const delay = Math.floor(Math.random() * 101); // 0-100ms
                    timeouts.push(setTimeout(() => {
                        setRevealedPlayers(prev => {
                            const next = new Set(prev);
                            next.add(r.playerIndex);
                            return next;
                        });
                    }, delay));
                });
                return () => timeouts.forEach(t => clearTimeout(t));
            }, [phase, results, tiles, playerCount]);

            // タイルごとに「どのプレイヤーが当選したか」を集約
            const winnersByTileId = useMemo(() => {
                const map = new Map();
                if (phase !== 'result' || !Array.isArray(results)) return map;
                results.forEach(r => {
                    if (!revealedPlayers.has(r?.playerIndex)) return;
                    const pid = r?.pokemon?.id;
                    const pname = r?.pokemon?.name;
                    // 盤面上のタイルIDに寄せて集約（停止タイルと結果の一致を最優先）
                    const winnerIndex = tiles.findIndex(t => t && (t.id === pid || (t.name && pname && t.name === pname)));
                    const tileId = winnerIndex >= 0 ? tiles[winnerIndex]?.id : pid;
                    if (!tileId) return;
                    if (!map.has(tileId)) map.set(tileId, []);
                    map.get(tileId).push(r.playerIndex);
                });
                return map;
            }, [phase, results, revealedPlayers, tiles]);

            const isActive = (tileIndex) => {
                if (phase !== 'spinning' && phase !== 'result') return false;
                return activeIndices.includes(tileIndex);
            };

            // 「このタイルを誰が踏んでいるか」を（spinning/result 共通で）集約
            const activePlayersByIndex = useMemo(() => {
                const map = new Map();
                if (phase !== 'spinning' && phase !== 'result') return map;
                activeIndices.forEach((idx, i) => {
                    const pi = i + 1;
                    if (!map.has(idx)) map.set(idx, []);
                    map.get(idx).push(pi);
                });
                return map;
            }, [phase, activeIndices]);

            return (
                <div className="w-full max-w-md md:max-w-3xl mx-auto my-8">
                    <div className="text-center text-white/70 text-xs md:text-sm mb-3 font-jp">
                        {phase === 'setup' && ''}
                        {phase === 'spinning' && '抽選中...'}
                        {phase === 'result' && '結果確定'}
                    </div>


                    <div className={`grid ${gridClass} gap-x-0.5 gap-y-0.5 md:gap-x-1 md:gap-y-1 justify-center content-start`}
                         style={{
                             // ランダムモードは「全タイルを同一盤面に表示」するため、盤面自体を伸ばして内側スクロールを作らない
                             padding: '6px'
                         }}>
                        {tiles.map((p, idx) => {
                            const winners = winnersByTileId.get(p.id) || [];
                            const activePlayers = activePlayersByIndex.get(idx) || [];

                            // 表示要件:
                            // - スピン中も「P1〜P5マーカー」は出さず、タイル外枠（ring）自体をプレイヤー色で光らせる
                            // - 結果確定も同様に、当選タイルの外枠をプレイヤー色で強調する
                            const spinPi = (phase === 'spinning' && activePlayers.length > 0) ? activePlayers[0] : null;
                            const resultPi = (phase === 'result' && winners.length > 0) ? winners[0] : null;
                            const spinRingClass = spinPi ? (playerColors[(spinPi - 1) % playerColors.length] || 'ring-white/80') : '';
                            const resultRingClass = resultPi ? (playerColors[(resultPi - 1) % playerColors.length] || 'ring-white/90') : '';

                            // 画像URL: 既存UIと同じ外部URL（dexId）を採用
                            const imgSrc = p?.dexId
                                ? `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.dexId}.png`
                                : '';

                            return (
                                <div key={p.id || idx}
                                     className={`relative ${tileClass} rounded-lg overflow-hidden border border-white/20 bg-black/20 shadow-sm transition-all duration-150
                                        ${spinPi ? `scale-110 ring-4 md:ring-8 ${spinRingClass} border-white/90 shadow-[0_0_30px_rgba(255,255,255,0.55)] animate-pulse` : ''}
                                        ${resultPi ? `ring-6 md:ring-10 ${resultRingClass} border-white shadow-[0_0_38px_rgba(255,255,255,0.75)]` : ''}
                                     `}>

                                    {imgSrc ? (
                                        <img
                                            src={imgSrc}
                                            alt={p.name}
                                            className="w-full h-full object-contain p-0.5"
                                            loading="lazy"
                                            onError={(e) => {
                                                e.currentTarget.onerror = null;
                                                e.currentTarget.src = 'https://placehold.co/150x150/111827/FFF?text=?';
                                            }}
                                        />
                                    ) : (
                                        <div className="w-full h-full flex items-center justify-center text-[10px] text-white/60 font-jp">?</div>
                                    )}

                                    {/* 要件により、P1〜P5マーカーは表示しない（枠色のみで表現） */}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const MultiRouletteDisplay = ({ phase, rotations, categoryMode, playerCount, results, tiles }) => {
            const getLaneForResult = (index) => {
                if (phase !== 'result' || !results || !results[index]) return null;
                return results[index].lane;
            };

            // 「完全ランダム」はルーレット盤面ではなく、全ポケモンタイル盤面で表現する。
            if (categoryMode === 'random') {
                return <TileSpinBoard phase={phase} playerCount={playerCount} results={results} tiles={tiles} tileSize={playerCount >= 4 ? 'sm' : 'md'} />;
            }

            if (playerCount === 1) {
                return (
                    <div className={`relative w-64 h-64 md:w-96 md:h-96 mx-auto mt-20 mb-8 transition-all duration-500 ${phase !== 'setup' ? 'scale-110' : ''}`}>
                         <div className={`absolute inset-0 rounded-full border-4 border-neon-cyan opacity-50 ${phase === 'spinning' ? 'animate-pulse' : ''} blur-md`}></div>
                         <div className="absolute -top-6 left-1/2 transform -translate-x-1/2 w-8 h-10 z-20 drop-shadow-xl">
                            <div className="w-0 h-0 border-l-[16px] border-l-transparent border-r-[16px] border-r-transparent border-t-[32px] border-t-neon-yellow"></div>
                        </div>
                        <RouletteDisc phase={phase} rotation={rotations[0]} categoryMode={categoryMode} isMulti={false} />
                        <div className="absolute top-1/2 -right-8 transform -translate-y-1/2 z-20">
                            <LaneSignal phase={phase} lane={getLaneForResult(0)} size="md" />
                        </div>
                    </div>
                );
            }

            const containerClass = `relative w-full aspect-square max-w-md md:max-w-3xl mx-auto ${playerCount === 5 ? 'mt-20 mb-4' : 'my-8'}`;
            const getPos = (i, total) => {
                if (total === 2) return i === 0 
                    ? { top: '5%', left: '5%' } 
                    : { bottom: '5%', right: '5%' };
                if (total === 3) {
                     if(i===0) return { top: '0%', left: '50%', transform: 'translate(-50%, 0)' };
                     if(i===1) return { bottom: '2%', left: '2%' };
                     if(i===2) return { bottom: '2%', right: '2%' };
                }
                if (total === 5) {
                    const angle = (i * 72 - 90) * (Math.PI / 180);
                    const r = 38; 
                    const x = 50 + r * Math.cos(angle);
                    const y = 50 + r * Math.sin(angle);
                    return { left: `${x}%`, top: `${y}%`, transform: 'translate(-50%, -50%)' };
                }
                return {};
            };
            const sizeClass = playerCount === 5 ? "w-36 h-36 md:w-56 md:h-56" : "w-44 h-44 md:w-72 md:h-72";

            return (
                 <div className={containerClass}>
                    <div className="absolute inset-0 flex items-center justify-center pointer-events-none"></div>
                    {[...Array(playerCount)].map((_, i) => (
                        <div key={i} className={`absolute ${sizeClass} transition-all duration-500`} style={getPos(i, playerCount)}>
                             <div className="absolute -top-3 left-1/2 transform -translate-x-1/2 w-3 h-5 z-20 drop-shadow-md">
                                <div className="w-0 h-0 border-l-[6px] border-l-transparent border-r-[6px] border-r-transparent border-t-[12px] border-t-neon-yellow"></div>
                            </div>
                            <RouletteDisc phase={phase} rotation={rotations[i]} categoryMode={categoryMode} isMulti={true} />
                             <div className="absolute -bottom-4 left-1/2 transform -translate-x-1/2 text-[10px] font-bold text-white bg-black/50 px-2 rounded-full z-30 font-jp">
                                P{i+1}
                             </div>
                             <div className="absolute bottom-0 -right-2 z-20">
                                <LaneSignal phase={phase} lane={getLaneForResult(i)} size="sm" />
                            </div>
                        </div>
                    ))}
                </div>
            );
        };

        const SettingsPanel = ({ filterMode, setFilterMode, playerCount }) => {
            const isSolo = playerCount === 1;
            const availableOptions = isSolo ? FILTER_OPTIONS : FILTER_OPTIONS.filter(o => !o.isSoloOnly);
            // 表示順を固定（2行×3列）
            const FILTER_DISPLAY_ORDER = ['default', 'carry', 'popular', 'tournament', 'tank_sup', 'endangered'];
            const orderedOptions = FILTER_DISPLAY_ORDER
                .map((id) => availableOptions.find((o) => o.id === id))
                .filter(Boolean);

            return (
                <div className="w-full max-w-md md:max-w-3xl mx-auto mt-4 px-4">
                     <h3 className="text-sm font-bold text-white/80 mb-2 flex items-center justify-center gap-2 font-jp">
                        <FilterIcon size={14} /> Filter <span className="text-[10px] opacity-60 ml-2 font-sans font-normal tracking-normal">排出対象を調整</span>
                    </h3>
	            <div className="grid gap-2 md:gap-4 grid-cols-3">
                        {orderedOptions.map(opt => (
                            <button key={opt.id} onClick={() => setFilterMode(opt.id)} className={`py-2 md:py-4 rounded-lg transition-all border flex flex-col items-center justify-center ${filterMode === opt.id ? 'bg-neon-pink text-white border-neon-yellow shadow-lg' : 'bg-black/20 text-white/60 border-transparent hover:bg-black/30'}`}>
		                        <div className="text-[10px] md:text-base font-bold block leading-tight font-jp whitespace-nowrap">{opt.name}</div>
                            </button>
                        ))}
                    </div>
                    <div className="text-center mt-1 h-4">
                        <span className="text-[9px] text-white/50 font-sans">{FILTER_OPTIONS.find(o => o.id === filterMode)?.desc}</span>
                    </div>
                </div>
            );
        };

        const CategorySelector = ({ selected, onSelect }) => (
            <div className="w-full max-w-md md:max-w-3xl mx-auto px-4 z-10 relative">
                 <h3 className="text-sm font-bold text-white/80 mb-2 flex items-center justify-center gap-2 font-jp">
                    <SettingsIcon size={14} /> Theme <span className="text-[10px] opacity-60 ml-2 font-sans font-normal tracking-normal">縛りテーマを選択</span>
                </h3>
                <div className="grid grid-cols-5 gap-2 md:gap-4">
                    {CATEGORY_MODES.map((cat) => (
                        <button key={cat.id} onClick={() => onSelect(cat.id)} className={`relative overflow-hidden p-1.5 md:p-3 rounded-xl border transition-all duration-300 flex flex-col items-center text-center group ${selected === cat.id ? 'glass-button selected scale-105' : 'glass-button border-white/20 hover:bg-white/20 text-white/70 hover:text-white'}`}>
                            <cat.icon className={`w-4 h-4 mb-1 ${selected === cat.id ? 'text-white' : 'text-cyan-300'}`} />
                            <span className="font-jp font-bold text-[9px] md:text-base leading-none">{cat.label}</span>
                            <span className="text-[10px] md:text-sm font-bold opacity-90 mt-0.5 leading-none font-sans whitespace-nowrap">{cat.sub}</span>
                        </button>
                    ))}
                </div>
            </div>
        );
        
        
const PlayerCountSelector = ({ 
    playerCount, 
    setPlayerCount, 
    isCompGuaranteeMode, 
    setIsCompGuaranteeMode
}) => (
    <div className="w-full max-w-md md:max-w-3xl mx-auto px-4 mb-4">
        <h3 className="text-sm font-bold text-white/80 mb-2 flex items-center justify-center gap-2 font-jp">
            <Users size={14} /> Players <span className="text-[10px] opacity-60 ml-2 font-sans font-normal tracking-normal">参加人数を選択</span>
        </h3>
        <div className="grid grid-cols-4 gap-2 md:gap-4 mb-2">
            {PLAYER_COUNTS.map((p) => (
                <button key={p.count} onClick={() => { setPlayerCount(p.count); if (p.count > 1) setIsCompGuaranteeMode(true); else setIsCompGuaranteeMode(false); }} className={`py-2 md:py-4 rounded-lg font-jp font-bold text-xs md:text-base transition-all border ${playerCount === p.count ? 'bg-neon-blue text-white border-white shadow-[0_0_10px_rgba(96,165,250,0.6)]' : 'bg-black/30 text-white/50 border-white/10 hover:bg-white/10'}`}>
                    {p.label}
                </button>
            ))}
        </div>

        <div className="flex flex-row flex-wrap items-center justify-center gap-4 mt-2 animate-in fade-in slide-in-from-top-1">
            {playerCount > 1 && (
                <label className="flex items-center cursor-pointer relative">
                    <input type="checkbox" checked={isCompGuaranteeMode} onChange={(e) => setIsCompGuaranteeMode(e.target.checked)} className="sr-only peer" />
                    <div className="relative w-10 h-5 bg-gray-700 rounded-full transition-colors peer-focus:outline-none peer-checked:bg-green-500 after:content-[''] after:absolute after:top-0.5 after:left-0.5 after:h-4 after:w-4 after:bg-white after:rounded-full after:transition-all peer-checked:after:translate-x-5"></div>
                    <span className="ml-2 text-xs font-bold text-white flex items-center gap-1 font-sans">
                        <ShieldCheck size={14} className={isCompGuaranteeMode ? "text-green-400" : "text-gray-400"}/> 
                        構成保証モード
                    </span>
                </label>
            )}
        </div>
    </div>
);

const SecondaryCandidates = ({ others, onSelect, categoryLabel, currentSelection, allSelections }) => {
            if (!others || others.length === 0) return null;
            const formatLabel = (label) => {
                 const match = label ? label.match(/^(.*?)(（.*）|\(.*\))?$/) : null;
                 return match ? match[1] : label;
            };
            const displayLabel = categoryLabel ? formatLabel(categoryLabel) : '条件';
            
            const otherPlayerPokemonIds = allSelections
                .filter(res => res.pokemon.id !== currentSelection.id)
                .map(res => res.pokemon.id);
            const filteredOthers = others.filter(p => !otherPlayerPokemonIds.includes(p.id));

            if (filteredOthers.length === 0) return (
                <div className="text-center text-[10px] text-white/40 mt-4">他に選択可能なポケモンがいません</div>
            );

            return (
                <div className="w-full max-w-sm md:max-w-3xl mx-auto mt-2 animate-in fade-in slide-in-from-bottom-4 duration-1000 delay-500">
                    <div className="text-center text-white/60 text-[10px] mb-1 flex items-center justify-center gap-2 font-sans">
                        <CheckCircle size={10} className="text-neon-cyan" />
                        ▼ {displayLabel}に当てはまる他の候補
                    </div>
                    <div className="glass-panel rounded-xl p-3 bg-black/20">
                         <div className="flex gap-2 overflow-x-auto pb-2 pt-1 custom-scrollbar snap-x px-1">
                            {filteredOthers.map(p => (
                                <div key={p.id} onClick={() => onSelect(p)} className="relative group flex-shrink-0 w-10 h-10 md:w-16 md:h-16 snap-start cursor-pointer transition-transform hover:scale-110 active:scale-95">
                                    <div className="aspect-square bg-white/10 rounded-lg overflow-hidden border border-white/10 hover:border-neon-cyan transition-colors">
                                        <img src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${p.dexId}.png`} className="w-full h-full object-contain p-0.5" onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/150x150/4C1D95/FFF?text=?'; }} />
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const ResultCard = ({ result, onReset }) => {
            const [show, setShow] = useState(false);
            const [displayPokemon, setDisplayPokemon] = useState(result.pokemon);
            
            useEffect(() => { const timer = setTimeout(() => setShow(true), 100); return () => clearTimeout(timer); }, []);
            
            const laneKey = result.lane === "上レーン" ? "Top" : result.lane === "中央エリア" ? "Mid" : "Bot";
            const isMatch = displayPokemon.lane.includes(laneKey);
            const getLaneColor = (l) => {
                if(l === '上レーン') return 'text-neon-pink';
                if(l === '中央エリア') return 'text-neon-yellow';
                if(l === '下レーン') return 'text-neon-cyan';
                return 'text-white';
            };
            const laneColorClass = getLaneColor(result.lane);

            const shareTwitter = () => {
                const url = 'https://unite-roulette.site/';
                const shuffledTags = [...displayPokemon.tags].sort(() => 0.5 - Math.random()).slice(0, 2);
                const tagsText = shuffledTags.join(' ');
                const laneText = (result && result.lane) ? `｜${result.lane}` : '';
                const typeLaneText = displayPokemon.type ? `${displayPokemon.type}タイプ${laneText}` : ((result && result.lane) ? result.lane : '');
                const text = `運命のルーレット結果
今日のポケモンは【${displayPokemon.name}】！
${typeLaneText}

${tagsText}
#UNITERoulette #PokemonUNITE
${url}`;
                window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
            };

            const formatCategoryLabel = (label) => {
                const match = label.match(/^(.*?)(（.*）|\(.*\))?$/);
                if (!match) return label;
                return (
                    <>
                        {match[1]}
                        {match[2] && <span className="block md:inline text-sm md:text-xl opacity-80 font-sans font-normal mt-1 md:mt-0 md:ml-2 tracking-normal">{match[2]}</span>}
                    </>
                );
            };

            const { lane, categoryLabel, categoryModeLabel, others } = result;
            let displayTags = isMatch ? [displayPokemon.tags[0], displayPokemon.tags[1], displayPokemon.tags[2]] : [displayPokemon.tags[0], displayPokemon.tags[3] || displayPokemon.tags[1], displayPokemon.tags[2]];

            return (
                <div className={`relative z-20 w-full max-w-sm md:max-w-3xl mx-auto py-2 px-4 transition-all duration-700 transform ${show ? 'translate-y-0 opacity-100 scale-100' : 'translate-y-10 opacity-0 scale-95'} ${!isMatch ? 'animate-shake' : ''}`}>
                    <ConfettiEffect trigger={show} />

                    <div className="bg-aeos-darker/80 p-2 md:p-6 rounded-3xl safe-pb">
                        <div className="w-full max-w-2xl mx-auto">
                            <div className="mb-3 glass-panel rounded-2xl p-4 md:p-6 text-center border-2 border-neon-pink bg-black/50 shadow-[0_0_20px_rgba(244,114,182,0.4)] relative overflow-hidden">
                                <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-neon-pink via-white to-neon-pink animate-pulse"></div>
                                <div className="text-[10px] text-white/80 uppercase tracking-[0.3em] mb-1 font-bold font-sans">Roulette Result</div>
                                <div className="font-black text-white drop-shadow-[0_2px_4px_rgba(0,0,0,0.8)] leading-tight my-1 font-jp text-xl md:text-3xl">
                                    {formatCategoryLabel(categoryLabel)}
                                </div>
                                <div className="text-[10px] text-neon-cyan font-bold tracking-wider opacity-80 mb-1 font-sans">{categoryModeLabel}</div>
                                
                                <div className={`mt-2 py-1 px-3 rounded-xl border inline-flex items-center gap-2 ${isMatch ? 'bg-neon-blue/20 border-neon-blue text-white' : 'bg-red-500/20 border-red-500 text-red-100'}`}>
                                    <div className={`text-sm md:text-xl font-bold flex items-center gap-1 ${laneColorClass} font-sans`}><MapPin size={14} /> {lane}</div>
                                    <div className="text-[10px] font-bold tracking-wider opacity-90 border-l border-white/20 pl-2 font-sans">{isMatch ? 'MATCH' : 'MISMATCH'}</div>
                                </div>
                            </div>

                            <div className={`glass-panel rounded-2xl overflow-hidden relative border-t border-l border-white/40 shadow-2xl ${!isMatch ? 'animate-glitch border-red-500/50' : ''}`}>
                                <div className={`h-1.5 w-full ${isMatch ? 'bg-gradient-to-r from-neon-cyan to-neon-blue' : 'bg-gradient-to-r from-red-500 to-orange-500'}`}></div>
                                <div className="p-4 flex flex-col items-center text-center relative z-10 bg-gradient-to-b from-black/20 to-transparent">
                                    <div className="bg-black/40 backdrop-blur-sm px-2 py-0.5 rounded-full border border-white/20 text-[10px] font-bold text-white/80 mb-1 tracking-wider uppercase font-jp">{displayPokemon.role}</div>
                                    <div className="w-40 h-40 md:w-64 md:h-64 mb-1 relative transition-all duration-300">
                                        <div className={`absolute inset-0 blur-xl rounded-full animate-pulse ${isMatch ? 'bg-neon-cyan/20' : 'bg-red-500/30'}`}></div>
                                        <img key={displayPokemon.id} src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${displayPokemon.dexId}.png`} alt={displayPokemon.name} className="w-full h-full object-contain relative z-10 drop-shadow-2xl animate-float" onError={(e) => { e.target.onerror = null; e.target.src = 'https://placehold.co/150x150/4C1D95/FFF?text=?'; }} />
                                    </div>
                                    <h2 className="text-xl md:text-3xl font-jp font-bold text-white mb-2">{displayPokemon.name}</h2>
                                    <div className="w-full space-y-1 mb-1">
                                        {displayTags.map((tag, idx) => (
                                            <div key={idx} className={`rounded-md py-0.5 px-2 text-[10px] md:text-sm font-sans border ${isMatch ? 'bg-white/10 text-white/90 border-white/10' : 'bg-red-900/30 text-red-100 border-red-500/30'}`}>{tag}</div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                            <SecondaryCandidates others={others} onSelect={setDisplayPokemon} categoryLabel={categoryLabel} currentSelection={displayPokemon} allSelections={[{pokemon: displayPokemon}]} />
                        </div>
                    </div>

                    <div className="mt-4 flex flex-col gap-2 items-center w-full max-w-2xl mx-auto">
                        <p className="text-[10px] text-white/50 flex items-center gap-1 font-sans"><Camera size={12} /> 端末機能でキャプチャしてシェアしてね！</p>
                        <button onClick={shareTwitter} className="w-full bg-[#1DA1F2] text-white font-bold py-2.5 md:py-4 px-4 rounded-xl shadow-lg flex items-center justify-center gap-2 hover:scale-105 transition-transform text-xs md:text-base font-jp"><Share2 size={16} /> Xでシェアする</button>
                    </div>
                    <div className="mt-3 w-full max-w-2xl mx-auto">
                        <button onClick={onReset} className="w-full bg-white/10 text-white/70 font-bold py-2.5 md:py-4 px-4 rounded-xl border border-white/20 flex items-center justify-center gap-2 hover:bg-white/20 transition-all text-xs md:text-base font-sans"><RefreshCw size={14} /> もう一度回す</button>
                    </div>
                </div>
            );
        };

        const ResultCardMini = ({ res, idx, onClick, isSelected }) => {
            const isMatch = res.synergy === 'MATCH';
            const formatLabelMini = (label) => {
                const match = label.match(/^(.*?)(（.*）|\(.*\))?$/);
                return match ? <>{match[1]} <span className="text-[0.7em] opacity-80 font-sans">{match[2]}</span></> : label;
            };

            const getLaneColor = (l) => {
                if(l === '上レーン') return 'text-neon-pink';
                if(l === '中央エリア') return 'text-neon-yellow';
                if(l === '下レーン') return 'text-neon-cyan';
                return 'text-white';
            };
            const laneColorClass = getLaneColor(res.lane);
            
            let cardClasses = `glass-panel rounded-xl p-2 md:p-4 relative overflow-hidden flex items-center gap-3 md:gap-6 cursor-pointer transition-all `;
            if (isSelected) cardClasses += 'border-neon-yellow ';
            else cardClasses += 'border-transparent ';

            if (!isMatch) cardClasses += 'border-l-4 border-l-red-500 !bg-red-900/20 ';
            else if (isSelected) cardClasses += 'bg-white/10 ';

            return (
                <div onClick={onClick} className={cardClasses}>
                    <div className="absolute top-0 left-0 bg-white/20 px-2 py-0.5 text-[10px] font-bold rounded-br-lg text-white font-jp">#{idx}</div>
                     <div className="w-12 h-12 md:w-20 md:h-20 flex-shrink-0 relative">
                         <img src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${res.pokemon.dexId}.png`} className="w-full h-full object-contain relative z-10" />
                    </div>
                    <div className="flex-grow min-w-0 flex flex-col justify-center">
                         <div className="text-sm md:text-xl font-bold text-neon-pink mb-0.5 font-jp truncate">{formatLabelMini(res.categoryLabel)}</div>
                         <div className="flex items-center justify-between">
                            <div className="text-xs md:text-lg font-bold text-white truncate leading-tight opacity-80 font-jp">{res.pokemon.name}</div>
                            <div className="flex flex-col items-end">
                                <div className={`text-lg md:text-2xl font-black flex items-center gap-1 ${laneColorClass} font-sans`}>
                                    <MapPin size={16} className="md:w-6 md:h-6"/> {res.lane}
                                </div>
                                {!isMatch && (
                                    <span className="text-[8px] font-bold text-red-100 bg-red-600 px-1.5 py-0.5 rounded-sm leading-none mt-0.5">MISMATCH</span>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const MultiResultView = ({ results, onReset, checkSynergy }) => {
            const [selectedIdx, setSelectedIdx] = useState(0);
            const [displayResults, setDisplayResults] = useState(results);

            useEffect(() => { setDisplayResults(results); }, [results]);

            const handleSwapPokemon = (newPokemon) => {
                const newDisplayResults = [...displayResults];
                const currentResult = newDisplayResults[selectedIdx];
                const newSynergy = checkSynergy(newPokemon, currentResult.lane);
                newDisplayResults[selectedIdx] = {
                    ...currentResult,
                    pokemon: newPokemon,
                    synergy: newSynergy,
                };
                setDisplayResults(newDisplayResults);
            };

            const shareTwitter = () => {
                const url = 'https://unite-roulette.site/';
                const names = displayResults.map(r => r.pokemon.name).join('/');
                const allTags = [...new Set(displayResults.flatMap(r => (r.pokemon.tags || [])))];
                const shuffledTags = allTags.sort(() => 0.5 - Math.random()).slice(0, 2);
                const tagsText = shuffledTags.join(' ');
                const text = `運命のルーレット結果\n今日のポケモンは【${names}】\n${tagsText}\n#UNITERoulette #PokemonUNITE\n${url}`;
                window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`, '_blank');
            };
            
            return (
                <div className="relative z-20 w-full max-w-md md:max-w-3xl mx-auto p-4 animate-in zoom-in-95 duration-500">
                    <ConfettiEffect />
                    
                    <div className="mb-2 text-center text-xs font-bold text-white font-sans">
                         <span className="text-neon-pink">MULTI-SQUAD:</span> この布陣で勝利を掴め！
                    </div>
                    <div className="bg-aeos-darker/50 p-2 rounded-2xl grid gap-2 md:gap-4 mb-2">
                        {displayResults.map((res, i) => (
                            <ResultCardMini key={res.playerIndex} res={res} idx={res.displayIndex} isSelected={selectedIdx === i} onClick={() => setSelectedIdx(i)} />
                        ))}
                    </div>
                    <div className="animate-in fade-in slide-in-from-bottom-2 duration-300">
                         <SecondaryCandidates 
                            others={displayResults[selectedIdx].others} 
                            onSelect={handleSwapPokemon} 
                            categoryLabel={displayResults[selectedIdx].categoryLabel}
                            currentSelection={displayResults[selectedIdx].pokemon}
                            allSelections={displayResults}
                        /> 
                         <p className="text-[9px] text-center text-white/40 mt-1 font-sans">リストをタップして他の候補に切り替えられます</p>
                    </div>
                    <div className="mt-4 flex flex-col gap-2 items-center">
                        <p className="text-[10px] text-white/50 flex items-center gap-1 font-sans"><Camera size={12} /> 結果をキャプチャしてシェア！</p>
                        <button onClick={shareTwitter} className="w-full bg-[#1DA1F2] text-white font-bold py-3 px-4 rounded-xl shadow-lg flex items-center justify-center gap-2 hover:scale-105 transition-transform text-sm font-jp"><Share2 size={18} /> Xでシェアする</button>
                        <button onClick={onReset} className="w-full bg-white/10 text-white/70 font-bold py-3 px-4 rounded-xl border border-white/20 flex items-center justify-center gap-2 hover:bg-white/20 transition-all text-sm font-sans"><RefreshCw size={16} /> もう一度回す</button>
                    </div>
                </div>
            );
        };

        
// --- Tournament Meta View ---
const TournamentMetaView = ({ onBack }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const filtered = useMemo(() => {
        if (!searchTerm) return TOURNAMENT_META_DATA;
        return TOURNAMENT_META_DATA.filter(d => d.name.includes(searchTerm));
    }, [searchTerm]);

    return (
        <div className="w-full max-w-4xl mx-auto px-4 pb-24 animate-in fade-in slide-in-from-bottom-4 duration-500">
            <div className="flex items-center justify-between mb-4 sticky top-0 bg-aeos-darker/90 backdrop-blur-md z-30 py-3 border-b border-white/10 -mx-4 px-4">
                <button onClick={onBack} className="flex items-center gap-1 text-white hover:text-neon-cyan transition-colors">
                    <ArrowLeft size={20} />
                    <span className="font-bold text-sm font-sans">戻る</span>
                </button>
                <h2 className="text-lg font-bold text-white font-jp flex items-center gap-2">
                    <Trophy size={20} className="text-neon-yellow" />
                    大会メタデータ
                    <span className="text-xs bg-white/10 px-2 py-0.5 rounded-full text-white/70 font-sans">{TOURNAMENT_META_DATA.length}匹</span>
                </h2>
            </div>

            <div className="mb-6 space-y-3">
                <div className="glass-panel p-3 rounded-xl flex flex-col gap-3">
                    <p className="text-[11px] text-white/70 leading-relaxed font-sans">
                        PUACL 2026 JAPAN LEAGUE Day1〜Day5（全293試合）のピック実績データです。<br/>
                        PUACL 2026 JAPAN LEAGUE 試合数一覧<br/>
                        Day 1: 58 試合 / Day 2: 56 試合 / Day 3: 59 試合 / Day 4: 57 試合 / Day 5: 63 試合 / 合計: 293 試合
                    </p>
                    <div className="relative">
                        <input 
                            type="text" 
                            placeholder="ポケモン名で検索" 
                            className="w-full bg-black/30 border border-white/20 rounded-lg py-2 md:py-3 px-4 text-sm md:text-base text-white placeholder-white/30 focus:outline-none focus:border-neon-cyan transition-colors font-sans"
                            value={searchTerm}
                            onChange={(e) => setSearchTerm(e.target.value)}
                        />
                    </div>
                </div>
            </div>

            <div className="glass-panel rounded-xl overflow-hidden">
                <div className="overflow-x-auto">
                    <table className="w-full text-left text-sm font-sans">
                        <thead className="bg-black/30 text-white/80 text-xs">
                            <tr>
                                <th className="p-3">ポケモン</th>
                                <th className="p-3 text-right">使用回数</th>
                            </tr>
                        </thead>
                        <tbody>
                            {filtered.map(d => (
                                <tr key={d.name} className="border-t border-white/10 hover:bg-white/5">
                                    <td className="p-3 font-bold text-white">{d.name}</td>
                                    <td className="p-3 text-right font-bold text-neon-yellow">{d.count}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
};

const Footer = ({ onOpenDatabase, onOpenTournamentMeta }) => (
    <footer className="w-full bg-aeos-darker text-[10px] md:text-xs py-10 px-4 mt-8 border-t border-white/10 font-sans">
        <div className="max-w-4xl md:max-w-6xl mx-auto">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-8 md:gap-12 mb-8">
                <div className="space-y-3">
                    <h3 className="font-display font-bold text-neon-pink text-lg tracking-wide border-l-4 border-neon-pink pl-3">UNITE Roulette</h3>
                    <h4 className="font-bold text-white text-xs">毎日のユナイトに、予測不能なワクワクを。</h4>
                    <p className="text-white/80 leading-relaxed text-left break-words-anywhere">
                        UNITE Rouletteは、ポケモンユナイトのピックやレーン選択に「偶然」の要素を取り入れることで、日々のプレイにおけるマンネリを解消し、新しい楽しみ方を発見するための戦術ルーレットです。「意外な組み合わせが強かった」「使っていなかったポケモンの魅力に気づいた」。そんな小さな発見が、ポケモンユナイトをより長く、深く楽しむきっかけになれば幸いです。
                    </p>
                    <p className="text-[9px] text-white/60 bg-white/5 p-2 rounded border border-white/10 text-left">
                        ※ランクマッチ等で遊ぶ際は、味方チームへの配慮や合意形成をお忘れなく。<br/>
                        いつでも楽しく、真剣に！
                    </p>
                </div>

                <div className="space-y-4">
                    <h3 className="font-display font-bold text-neon-yellow text-lg tracking-wide border-l-4 border-neon-yellow pl-3">HOW TO USE</h3>
                    <div className="grid grid-cols-1 gap-3">
                        <div className="flex items-center gap-3 bg-white/5 p-2 rounded-lg">
                            <div className="w-8 h-8 rounded-full bg-neon-cyan/20 flex items-center justify-center text-neon-cyan font-bold">1</div>
                            <div>
                                <div className="text-neon-cyan font-bold">Players</div>
                                <div className="text-white/70">ソロからフルパまで。人数分の条件を一括抽選。</div>
                            </div>
                        </div>
                        <div className="flex items-center gap-3 bg-white/5 p-2 rounded-lg">
                            <div className="w-8 h-8 rounded-full bg-neon-pink/20 flex items-center justify-center text-neon-pink font-bold">2</div>
                            <div>
                                <div className="text-neon-pink font-bold">Theme</div>
                                <div className="text-white/70">「タイプ統一」など、その日の縛りを決定。</div>
                            </div>
                        </div>
                        <div className="flex items-center gap-3 bg-white/5 p-2 rounded-lg">
                            <div className="w-8 h-8 rounded-full bg-neon-yellow/20 flex items-center justify-center text-neon-yellow font-bold">3</div>
                            <div>
                                <div className="text-neon-yellow font-bold">Filter</div>
                                <div className="text-white/70">排出されるポケモンのプールを好みに調整。</div>
                            </div>
                        </div>
                        <div className="flex items-center gap-3 bg-white/5 p-2 rounded-lg">
                            <div className="w-8 h-8 rounded-full bg-white/10 flex items-center justify-center text-white font-bold">4</div>
                            <div>
                                <div className="text-white font-bold">Spin!</div>
                                <div className="text-white/70">準備ができたら、ボタンを押して運命を回そう！</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div className="space-y-4">
                    <h3 className="font-display font-bold text-neon-cyan text-lg tracking-wide border-l-4 border-neon-cyan pl-3">FEATURES & SPECS</h3>
                    <div className="space-y-3">
                        <div>
                            <h4 className="font-bold text-white text-xs mb-1 flex items-center gap-1"><DatabaseIcon size={12}/> Pokémon DATA</h4>
                            <p className="text-white/70">タイプやバトルスタイルを網羅した全86匹のデータを搭載。（2026/1/11更新）</p>

                            <div className="mt-3 flex justify-center">
                                <button
                                    onClick={onOpenDatabase}
                                    className="bg-neon-cyan/20 text-neon-cyan border border-neon-cyan/50 hover:bg-neon-cyan hover:text-aeos-darker font-bold py-2 px-6 rounded-full transition-all text-xs flex items-center gap-2 font-jp w-full max-w-xs justify-center"
                                >
                                    <DatabaseIcon size={14} />
                                    収録ポケモンリストを見る
                                </button>
                            </div>

                            <div className="mt-2 flex justify-center">
                                <button
                                    onClick={onOpenTournamentMeta}
                                    className="bg-neon-cyan/20 text-neon-cyan border border-neon-cyan/50 hover:bg-neon-cyan hover:text-aeos-darker font-bold py-2 px-6 rounded-full transition-all text-xs flex items-center gap-2 font-jp w-full max-w-xs justify-center"
                                >
                                    <Trophy size={14} />
                                    大会メタデータを見る
                                </button>
                            </div>
                        </div>

                        <div>
                            <h4 className="font-bold text-white text-xs mb-1 flex items-center gap-1"><FilterIcon size={12}/> FILTER</h4>
                            <p className="text-white/70 text-[10px]">指定なし／大会メタ／キャリー／サポタン／ピック率上位／ピック率下位 の6種フィルタを利用できます。</p>
                        </div><div>
                            <h4 className="font-bold text-white text-xs mb-1 flex items-center gap-1"><Users size={12}/> MULTI & MODES</h4>
                            <p className="text-white/70 text-[10px]">人数に合わせた最適なレーン配分に加え、無理な構成を避ける「構成保証モード」 環境のトップメタを優先して選出する「大会メタモード」を搭載。</p>
                            <p className="text-white/60 text-[10px] mt-1 leading-relaxed">
                                構成保証モード：適正レーン選出に加え、各レーンに「サポート,タンク」を1匹採用。<br/>
                                大会メタモード：PUACL 2026 JAPAN LEAGUE Day1〜Day5（全293試合）のデータから選出。
                            </p>
                        </div>


                        <div>
                            <h4 className="font-bold text-white text-xs mb-1 flex items-center gap-1"><ShieldCheck size={12}/> SYSTEM NOTE</h4>
                            <p className="text-white/70 text-[10px]">「フィルタ × テーマ × 事故軽減」等で組み合わせが存在しない場合でも大丈夫。システムが自動的に条件を緩和し、最適なポケモンを選出します。</p>
                        </div>

                        <div>
                            <h4 className="font-bold text-white text-xs mb-1">Developer&apos;s Note</h4>
                            <p className="text-white/70 text-[10px] leading-relaxed">
                                最適解を突き詰めるのもMOBAの醍醐味ですが、たまには運命に身を任せるのも悪くないですよね。このツールが、友人との会話のネタや、新しい「推し」を見つけるきっかけになれば嬉しいです。GLHF!
                            </p>
                        </div>
                    </div>
                </div>
            </div>

            <div className="text-center text-white/40 text-[10px] border-t border-white/10 pt-6">
                UNITE Roulette
            </div>
            <div className="text-center text-white/35 text-[10px] mt-3 leading-relaxed">
                本サイトは非公式のファンメイドプロジェクトであり、任天堂・株式会社ポケモン・TiMi Studio Group・Tencent とは関係ありません。<br />
                「Pokémon」「Pokémon UNITE」等の商標は各権利者に帰属します。
            </div>
        </div>
    </footer>
);

        // --- Logic Hooks ---
        const useRoulette = () => {
            const [filterMode, setFilterMode] = useState('default');
            const [categoryMode, setCategoryMode] = useState('elements'); // Default to Looks
            const [playerCount, setPlayerCount] = useState(1);
            const [isCompGuaranteeMode, setIsCompGuaranteeMode] = useState(false);
            const [phase, setPhase] = useState('setup');
            const [results, setResults] = useState([]);
            const [rotations, setRotations] = useState([0, 0, 0, 0, 0]);
            
            const { startSpinSound, slowdownSpinSound, playResultSound } = useAudio();
            
            const checkSynergy = (pokemon, lane) => {
                const laneKey = lane === "上レーン" ? "Top" : lane === "中央エリア" ? "Mid" : "Bot";
                const best = pokemon.lane;
                if (best.includes(laneKey)) return "MATCH";
                return "MISMATCH";
            };

            // 構成保証ロジック: 設定(CONFIG_TANK_SUPPORT_EXCEPTIONS)を使用
            const isTankOrSupport = (p) => ['Defender', 'Supporter'].includes(p.role) || CONFIG_TANK_SUPPORT_EXCEPTIONS.includes(p.id);

            const getPool = () => {
                let pool = POKEMON_DB;
                if (filterMode === 'popular') pool = POKEMON_DB.filter(p => PICKRATE_TOP_SET.has(p.name));
                else if (filterMode === 'endangered') pool = POKEMON_DB.filter(p => PICKRATE_BOTTOM_SET.has(p.name));
                else if (filterMode === 'tournament') pool = POKEMON_DB.filter(p => TOURNAMENT_META_SET.has(p.name));
                else if (filterMode === 'carry') {
                    pool = POKEMON_DB.filter(p => 
                        ['Attacker', 'Speedster', 'All-Rounder'].includes(p.role) && !CONFIG_TANK_SUPPORT_EXCEPTIONS.includes(p.id)
                    );
                }
                else if (filterMode === 'tank_sup') {
                    pool = POKEMON_DB.filter(p => 
                        ['Defender', 'Supporter'].includes(p.role) || CONFIG_TANK_SUPPORT_EXCEPTIONS.includes(p.id)
                    );
                }
                return pool;
            };

            const spin = () => {
                window.scrollTo({ top: 0, behavior: 'smooth' });
                startSpinSound(); 
                setPhase('spinning');
                setResults([]);

                const isRandomMode = categoryMode === 'random';
                const modeDef = CATEGORY_MODES.find(m => m.id === categoryMode);
                const itemsCount = isRandomMode ? 8 : modeDef.items.length;
                const degPerItem = 360 / itemsCount;
                
                const newResults = [];
                const newRotations = [...rotations];
                const usedPokemonIds = new Set();
                const currentPool = getPool();
                // DBインデックスをモード定義から取得 (Ver 24.0)
                const targetDbIndex = modeDef.dbIndex;

                let selectedLanes = [];
                if (playerCount === 2) {
                    const lane = Math.random() < 0.5 ? '上レーン' : '下レーン';
                    selectedLanes = [lane, lane];
                } else if (playerCount === 3) {
                    const side = Math.random() < 0.5 ? '上レーン' : '下レーン';
                    selectedLanes = ['中央エリア', side, side];
                    selectedLanes.sort(() => 0.5 - Math.random());
                } else {
                    let availableLanes = [...LANE_POOL_TEMPLATE];
                    for (let i = availableLanes.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [availableLanes[i], availableLanes[j]] = [availableLanes[j], availableLanes[i]];
                    }
                    selectedLanes = availableLanes.slice(0, playerCount);
                }

                for (let i = 0; i < playerCount; i++) {
                    let candidates = [];
                    let categoryName = '';
                    let catIndex = 0;

                    if (isRandomMode) {
                        candidates = currentPool;
                        categoryName = '完全ランダム';
                        const randomSeg = Math.floor(Math.random() * itemsCount);
                        const targetAbs = -(randomSeg * degPerItem + degPerItem / 2);
                        let diff = targetAbs - (newRotations[i] % 360);
                        while (diff < 0) diff += 360;
                        diff += 360 * 4; 
                        newRotations[i] += diff;

                    } else {
                        catIndex = Math.floor(Math.random() * itemsCount);
                        categoryName = modeDef.items[catIndex];
                        if (categoryName === 'ネイチャー') categoryName = 'ネイチャー(くさ、むし、どく、ひこう)';
                        if (categoryName === 'マテリアル') categoryName = 'マテリアル(はがね、いわ、こおり、じめん)';

                        const targetAbs = -(catIndex * degPerItem + degPerItem / 2);
                        let diff = targetAbs - (newRotations[i] % 360);
                        while (diff < 0) diff += 360;
                        diff += 360 * 4; 
                        newRotations[i] += diff;

                        candidates = currentPool.filter(p => {
                            // 安全なアクセス (p.cats[undefined]を防ぐ)
                            if (targetDbIndex === null || targetDbIndex === undefined) return true;
                            const cats = p.cats[targetDbIndex];
                            return Array.isArray(cats) ? cats.includes(catIndex) : cats === catIndex;
                        });

                        if (candidates.length === 0) {
                            candidates = POKEMON_DB.filter(p => {
                                 if (targetDbIndex === null) return true;
                                 const cats = p.cats[targetDbIndex];
                                 return Array.isArray(cats) ? cats.includes(catIndex) : cats === catIndex;
                            });
                        }
                    }
                    
                    let availableCandidates = candidates.filter(p => !usedPokemonIds.has(p.id));
                    const lane = playerCount === 1 ? ["上レーン", "中央エリア", "下レーン"][Math.floor(Math.random() * 3)] : selectedLanes[i];
                    
                    let finalCandidates = availableCandidates;
                    
if (isCompGuaranteeMode && playerCount > 1) {
    const synergyCandidates = availableCandidates.filter(p => checkSynergy(p, lane) === 'MATCH');
    if (synergyCandidates.length > 0) finalCandidates = synergyCandidates;

    const totalInLane = selectedLanes.filter(l => l === lane).length;
    const currentResultsInLane = newResults.filter(r => r.lane === lane);
    const isLastSlotForLane = currentResultsInLane.length === totalInLane - 1;
    const guaranteeCount = currentResultsInLane.filter(r => isTankOrSupport(r.pokemon)).length;

    // 各レーンで「サポタン＋スイクン」を必ず1匹、かつ1匹まで
    if (guaranteeCount >= 1) {
        const nonGuaranteeCandidates = finalCandidates.filter(p => !isTankOrSupport(p));
        if (nonGuaranteeCandidates.length > 0) finalCandidates = nonGuaranteeCandidates;
    } else if (isLastSlotForLane) {
        const guaranteeCandidates = finalCandidates.filter(isTankOrSupport);
        if (guaranteeCandidates.length > 0) finalCandidates = guaranteeCandidates;
    }
}

if (finalCandidates.length === 0) finalCandidates = candidates;

                    let picked = null;
                    let shuffled = [...finalCandidates].sort(() => 0.5 - Math.random());
                    picked = shuffled[0];

                    if (picked) usedPokemonIds.add(picked.id);

                    const synergy = picked ? checkSynergy(picked, lane) : 'MISMATCH';
                    const others = isRandomMode ? [] : candidates.sort(() => 0.5 - Math.random());

                    newResults.push({
                        playerIndex: i + 1,
                        pokemon: picked,
                        lane: lane,
                        categoryLabel: categoryName,
                        categoryModeLabel: modeDef.label,
                        isFallback: false,
                        synergy,
                        others
                    });
                }
                
                setRotations(newRotations);

                // 停止タイルと結果表示を一致させるため、当選結果はスピン開始時点で確定させて渡す
                // （phase が result になるまでは結果UIは出ないため表示上の問題はない）
                setResults(newResults);

                if (playerCount > 1) {
                    const laneOrder = { "上レーン": 1, "中央エリア": 2, "下レーン": 3 };
                    newResults.sort((a, b) => laneOrder[a.lane] - laneOrder[b.lane]);
                    newResults.forEach((r, idx) => r.displayIndex = idx + 1);
                } else {
                    newResults[0].displayIndex = 1;
                }

                setTimeout(() => {
                    slowdownSpinSound();
                    setTimeout(() => {
                        setResults(newResults);
                        setPhase('result');
                        playResultSound(true);
                    }, 800);
                }, 3000);
            };

            const reset = () => {
                setPhase('setup');
                setResults([]);
            };

            return { filterMode, setFilterMode, categoryMode, setCategoryMode, playerCount, setPlayerCount, isCompGuaranteeMode, setIsCompGuaranteeMode, phase, results, spin, reset, rotations, checkSynergy, getPool };
        };

        const ParticleBackground = () => (
            <div className="fixed inset-0 pointer-events-none z-0 overflow-hidden">
                {[...Array(20)].map((_, i) => (
                    <div key={i} className="particle" style={{left: `${Math.random()*100}%`, width: `${Math.random()*10+5}px`, height: `${Math.random()*10+5}px`, '--duration': `${Math.random()*10+10}s`, animationDelay: `${Math.random()*5}s`}} />
                ))}
            </div>
        );

        const App = () => {
            const { filterMode, setFilterMode, categoryMode, setCategoryMode, playerCount, setPlayerCount, isCompGuaranteeMode, setIsCompGuaranteeMode, phase, results, spin, reset, rotations, checkSynergy, getPool } = useRoulette();
            const [currentView, setCurrentView] = useState('roulette');

            const handleViewDatabase = () => { window.scrollTo(0, 0); setCurrentView('database'); };
            const handleViewTournamentMeta = () => { window.scrollTo(0, 0); setCurrentView('tournament_meta'); };
            const handleBackToRoulette = () => { window.scrollTo(0, 0); setCurrentView('roulette'); };

            // 初期表示(マウント)されるまでメインコンテンツを表示しない (FOUC防止)
            const [mounted, setMounted] = useState(false);
            useEffect(() => { setMounted(true); }, []);

            if (!mounted) return <div className="min-h-screen bg-aeos-darker"></div>;

            return (
                <div className="min-h-screen relative font-sans text-white selection:bg-neon-pink selection:text-white flex flex-col">
                    <ParticleBackground />
                    <Header />
                    <main className="container mx-auto px-4 relative z-10 flex-grow flex flex-col items-center justify-start min-h-[500px]">
                        
                        {currentView === 'database' && (
                            <DatabaseView onBack={handleBackToRoulette} filterMode={filterMode} categoryMode={categoryMode} isCompGuaranteeMode={isCompGuaranteeMode} />
                        )}


                        {currentView === 'tournament_meta' && (
                            <TournamentMetaView onBack={handleBackToRoulette} />
                        )}

                        {currentView === 'roulette' && (
                            <>
                                {phase !== 'result' && (
                                    <div className={`w-full flex flex-col items-center duration-500 ${phase === 'setup' ? 'animate-in fade-in slide-in-from-bottom-4' : ''}`}>
                                        <div className={`transition-opacity duration-300 w-full ${phase !== 'setup' ? 'opacity-0 pointer-events-none h-0 overflow-hidden' : 'opacity-100'}`}>
                                            <PlayerCountSelector playerCount={playerCount} setPlayerCount={setPlayerCount} isCompGuaranteeMode={isCompGuaranteeMode} setIsCompGuaranteeMode={setIsCompGuaranteeMode} />
                                            <CategorySelector selected={categoryMode} onSelect={setCategoryMode} />
                                        </div>

                                        <MultiRouletteDisplay phase={phase} rotations={rotations} categoryMode={categoryMode} playerCount={playerCount} results={results} tiles={getPool()} />

                                        {phase === 'setup' && (
                                            <>
                                                <SettingsPanel filterMode={filterMode} setFilterMode={setFilterMode} playerCount={playerCount} />
                                                <div className="mt-8 mb-6 w-full max-w-xs md:max-w-md">
                                                    <button onClick={spin} className="w-full group relative spin-button-container">
                                                        <div className="absolute inset-0 bg-neon-pink rounded-full blur opacity-75 group-hover:opacity-100 transition-opacity animate-breathing"></div>
                                                        <div className="relative bg-gradient-to-r from-neon-pink to-purple-600 rounded-full p-1 spin-button-inner overflow-hidden">
                                                            <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent w-full h-full animate-shimmer"></div>
                                                            <div className="bg-white/10 backdrop-blur-md rounded-full py-4 px-8 md:py-6 md:px-12 border border-white/50 flex items-center justify-center gap-3 relative z-10">
                                                                <span className="text-2xl md:text-4xl font-jp font-bold tracking-widest text-white drop-shadow-md">SPIN!</span>
                                                            </div>
                                                        </div>
                                                    </button>
                                                </div>
                                            </>
                                        )}
                                        {phase !== 'setup' && <h2 className="text-xl font-bold text-white mb-8 animate-pulse text-glow font-jp">運命を抽選中...</h2>}
                                    </div>
                                )}
                                {phase === 'result' && results.length === 1 && <ResultCard result={results[0]} onReset={reset} />}
                                {phase === 'result' && results.length > 1 && <MultiResultView results={results} onReset={reset} checkSynergy={checkSynergy} />}
                                
                                <Footer onOpenDatabase={handleViewDatabase} onOpenTournamentMeta={handleViewTournamentMeta} />
                            </>
                        )}
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>